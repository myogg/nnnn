<?xml version="1.0" encoding="utf-8"?>
<feed version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

  <title>Blog · Loji44</title>
  <link>https://loji44.github.io</link>
  <language>zh-CN</language>
  <pubDate>Tue, 18 Jan 2022 15:22:23 +0000</pubDate>
  <lastBuildDate>Tue, 18 Jan 2022 15:22:23 +0000</lastBuildDate>
  <generator>Jekyll v4.2.1</generator>
  <atom:link href="https://loji44.github.io/rss.xml" rel="self" type="application/rss+xml" />

  
    <item>
      <title>pip/pip3配置国内源，为Python包的安装加速</title>
      <link>/2022/01/16/pip-config.html</link>
      <content><p><code class="language-plaintext highlighter-rouge">midkr ~/.pip &amp;&amp; vim ~/.pip/pip.conf</code>编辑pip配置文件，加入以下内容：</p>

<pre><code class="language-txt">[global]
timeout=60
index-url=https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<p>更多配置项可以参考官网配置说明：<a href="https://pip.pypa.io/en/stable/topics/configuration" target="_blank">https://pip.pypa.io/en/stable/topics/configuration</a></p>

<p>国内可选pip源：</p>

<ul>
  <li>清华大学镜像：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank">https://pypi.tuna.tsinghua.edu.cn/simple</a></li>
  <li>阿里云源：<a href="http://mirrors.aliyun.com/pypi/simple" target="_blank">http://mirrors.aliyun.com/pypi/simple</a></li>
  <li>豆瓣软件源：<a href="http://pypi.douban.com/simple" target="blank">http://pypi.douban.com/simple<a></a></a></li>
  <li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple" target="_blank">https://pypi.mirrors.ustc.edu.cn/simple</a></li>
  <li>华中理工大学：<a href="http://pypi.hustunique.com" target="_blank">http://pypi.hustunique.com</a></li>
  <li>山东理工大学：<a href="http://pypi.sdutlinux.org" target="_blank">http://pypi.sdutlinux.org</a></li>
</ul>

<hr />

<p>参考：</p>
<ul>
  <li><a href="https://pip.pypa.io/en/stable/topics/configuration" target="_blank">https://pip.pypa.io/en/stable/topics/configuration</a></li>
  <li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/" target="_blank">清华大学开源软件镜像站：pypi 镜像使用帮助</a></li>
</ul>

</content>
      <pubDate>Sun, 16 Jan 2022 09:20:02 +0000</pubDate>
      <gui>/2022/01/16/pip-config.html</gui>
    </item>
  
    <item>
      <title>树莓派4B上使用Docker安装MySQL</title>
      <link>/2022/01/06/install-mysql-on-raspberrypi-with-docker.html</link>
      <content><p>树莓派4B属于ARM架构，想要在上面安装MySQL，必须选择适配ARM平台的MySQL Docker镜像。MySQL官方出了一个可以在ARM平台上运行的镜像：<a href="https://registry.hub.docker.com/r/mysql/mysql-server" target="_blank">https://registry.hub.docker.com/r/mysql/mysql-server</a></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker pull mysql/mysql-server:8.0.27-aarch64
</code></pre></div></div>

<p>这里使用Docker-compose运行，编辑<code class="language-plaintext highlighter-rouge">docker-compose.yaml</code>内容如下：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">mysql-server</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mysql/mysql-server:8.0.27-aarch64</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">mysql-server</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">3306:3306"</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MYSQL_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">root_pass</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">/xxx/docker/volumes/mysql-server/data:/var/lib/mysql"</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
</code></pre></div></div>

<p>启动MySQL docker容器：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose up <span class="nt">-d</span> mysql-server
</code></pre></div></div>

<p>使用命令<code class="language-plaintext highlighter-rouge">docker logs -f mysql-server</code>查看MySQL服务器日志，看到<code class="language-plaintext highlighter-rouge">ready for connections</code>字样就说明成功运行起来了。MySQL默认仅支持本地<code class="language-plaintext highlighter-rouge">localhost</code>连接，需要设置MySQL开启支持远程连接，步骤如下。</p>

<p>执行<code class="language-plaintext highlighter-rouge">docker exec -ti mysql-server bash</code>命令进入MySQL容器中，然后使用<code class="language-plaintext highlighter-rouge">mysql</code>命令连接MySQL：<code class="language-plaintext highlighter-rouge">mysql -h localhost -P 3306 -u root -proot_pass</code>。成功连接上后，给root用户授权远程连接：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; USE mysql<span class="p">;</span>
Reading table information <span class="k">for </span>completion of table and column names
You can turn off this feature to get a quicker startup with <span class="nt">-A</span>

Database changed
mysql&gt; SELECT user, host FROM user<span class="p">;</span>
+------------------+-----------+
| user             | host      |
+------------------+-----------+
| healthchecker    | localhost |
| mysql.infoschema | localhost |
| mysql.session    | localhost |
| mysql.sys        | localhost |
| root             | localhost |
+------------------+-----------+
5 rows <span class="k">in </span><span class="nb">set</span> <span class="o">(</span>0.00 sec<span class="o">)</span>

mysql&gt; UPDATE user SET <span class="nv">host</span><span class="o">=</span><span class="s1">'%'</span> WHERE user <span class="o">=</span> <span class="s1">'root'</span><span class="p">;</span>
Query OK, 1 row affected <span class="o">(</span>0.02 sec<span class="o">)</span>

mysql&gt; SELECT user, host FROM user<span class="p">;</span>
+------------------+-----------+
| user             | host      |
+------------------+-----------+
| root             | %         |
| healthchecker    | localhost |
| mysql.infoschema | localhost |
| mysql.session    | localhost |
| mysql.sys        | localhost |
+------------------+-----------+
5 rows <span class="k">in </span><span class="nb">set</span> <span class="o">(</span>0.01 sec<span class="o">)</span>

mysql&gt; FLUSH PRIVILEGES<span class="p">;</span>
Query OK, 0 rows affected <span class="o">(</span>0.02 sec<span class="o">)</span>
</code></pre></div></div>

<p>成功执行<code class="language-plaintext highlighter-rouge">UPDATE user SET host='%' WHERE user = 'root';</code>之后记得执行<code class="language-plaintext highlighter-rouge">FLUSH PRIVILEGES;</code>刷新权限！</p>

<p>MySQL8之后，用户管理和权限管理跟之前版本命令的使用方式有所不同，参考官方说明：<a href="https://dev.mysql.com/doc/refman/8.0/en/grant.html" target="_blank">https://dev.mysql.com/doc/refman/8.0/en/grant.html</a></p>

<hr />

<p>参考：</p>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/grant.html" target="_blank">https://dev.mysql.com/doc/refman/8.0/en/grant.html</a></li>
  <li><a href="https://www.cnblogs.com/dongxt/p/14883465.html" target="_blank">MySQL8.0以上版本创建用户并授权远程连接</a></li>
</ul>

</content>
      <pubDate>Thu, 06 Jan 2022 14:43:59 +0000</pubDate>
      <gui>/2022/01/06/install-mysql-on-raspberrypi-with-docker.html</gui>
    </item>
  
    <item>
      <title>Windows迟滞键后门sethc.exe</title>
      <link>/2021/08/17/sethc.exe.html</link>
      <content><p><code class="language-plaintext highlighter-rouge">sethc.exe</code>是Windows的迟滞键执行程序，即连续按下5次<code class="language-plaintext highlighter-rouge">shift</code>键之后，会弹出迟滞键弹窗：</p>

<p><img src="/static/image/2021/shift5.jpg" alt="shift5.jpg" /></p>

<p>这个迟滞键往往会被利用进行一些不安全的入侵操作，例如修改登录密码。利用“启动修复”功能，就可以将<code class="language-plaintext highlighter-rouge">cmd.exe</code>命令控制台程序替换成<code class="language-plaintext highlighter-rouge">sethc.exe</code>，这样在登录窗口就可以连续按下5次<code class="language-plaintext highlighter-rouge">shift</code>键，调出命令控制台，继而通过<code class="language-plaintext highlighter-rouge">net user new_pass</code>修改用户登录密码。</p>

<p>这类后门的原理是通过将<code class="language-plaintext highlighter-rouge">cmd.exe</code>重命名成其他快捷键等方式执行程序，例如上述例子说的，将<code class="language-plaintext highlighter-rouge">cmd.exe</code>重命名成<code class="language-plaintext highlighter-rouge">sethc.exe</code>来欺骗操作系统，调出命令控制台进而修改登录密码。所以应对方式就是禁用或者对一些快捷键进行权限配置，可以参考：<a href="https://baike.baidu.com/item/sethc.exe/249570" target="_blank">https://baike.baidu.com/item/sethc.exe/249570</a></p>

<hr />

<p>延伸阅读：<a href="https://www.zhihu.com/question/29748629/answer/646431616" target="_blank">迟滞键是谁发明的？</a> 这里摘抄一部分：</p>

<p>“粘滞键是80年代初发明的，当时叫 1-Finger，顾名思义初衷是帮助只有「一根手指」的用户。比如键入「@」，需要同时按住 Shift 和 2，这时候粘滞键就可以起作用了。当然，这个功能帮助到的人群远不止「一根手指」。有个天生双臂缺失的大爷给我演示过，他是怎么用电脑的，粘滞键发明前他是怎么解决 Ctrl Shift 这些功能键的：他嘴里咬一根木棍儿，一头缠几圈橡皮筋——这是他操作电脑唯一的工具；然后他让家人帮他把5个一美分硬币摞在一起，用透明胶缠住，一坨硬币的一面再缠上一个小铁环，让木棍儿的橡皮头刚好可以穿过。需要按住 Shift 的时候，用木棍儿把一坨硬币吊到 Shift 上，重量刚好可以把键按下，再去按别的键，用完再把硬币吊走。”</p>

<hr />

</content>
      <pubDate>Tue, 17 Aug 2021 04:09:20 +0000</pubDate>
      <gui>/2021/08/17/sethc.exe.html</gui>
    </item>
  
    <item>
      <title>使用jekyll-archives插件自动生成文章归档页面</title>
      <link>/2021/08/05/jekyll-archives-plugin.html</link>
      <content><p>在做 <a href="https://github.com/loji44/ExSimple" target="_blank">ExSimple</a> 博客主题的时候，被一个问题困扰了一天：如何自动根据标签<code class="language-plaintext highlighter-rouge">tag</code>自动生成页面，因为写文章的时候会随时新增新的标签。我如何能在新增<code class="language-plaintext highlighter-rouge">tag</code>的时候，自动生成<code class="language-plaintext highlighter-rouge">tag</code>下面的所有文章列表页面？</p>

<p>首先我已经写了<code class="language-plaintext highlighter-rouge">tag_post_list.html</code>这个layout，结合<a href="https://github.com/jekyll/jekyll-archives" target="https://github.com/jekyll/jekyll-archives">jekyll-archives</a>插件自动根据tag生成文章归档页面。<code class="language-plaintext highlighter-rouge">_config.yml</code>配置如下：</p>

<pre><code class="language-txt">plugins:
  - jekyll-archives
jekyll-archives:
  enabled: ['tags']
  layout: tag_post_list
  permalinks:
    tag: '/tags/:name.html'
</code></pre>

<p>在执行<code class="language-plaintext highlighter-rouge">bundle install &amp;&amp; jekyll build</code>生成博客静态资源文件时，就会根据tag归档生成归档页面，生成归档html页面所存放的路径为<code class="language-plaintext highlighter-rouge">_site/tags/</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loji44@Ubuntu:~/i44/_site/tags<span class="nv">$ </span>tree
<span class="nb">.</span>
├── arthas.html
├── auth.html
├── docker.html
├── dubbo.html
├── iterm2.html
├── java.html
├── jekyll.html
├── linux.html
├── macos.html
├── mybatis.html
├── mysql.html
├── python.html
├── redis.html
├── spi.html
├── spring.html
├── sso.html
├── windows.html
├── 博客.html
├── 图片.html
├── 工具集.html
└── 树莓派.html
</code></pre></div></div>

<hr />

</content>
      <pubDate>Thu, 05 Aug 2021 07:00:00 +0000</pubDate>
      <gui>/2021/08/05/jekyll-archives-plugin.html</gui>
    </item>
  
    <item>
      <title>Java运行时利用反射获取方法的参数名称</title>
      <link>/2021/01/04/java-reflection-get-method-parameter-real-name.html</link>
      <content><p>JDK1.8之前，我们通过反射获取一个方法定义的参数名称时，无法获取到真实的参数名称，例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">func</span><span class="o">(</span><span class="nc">String</span> <span class="n">nickName</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"something to be return"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在类编译之后，类的方法参数名称会丢失，通过反射机制获取到的参数名称变成了<code class="language-plaintext highlighter-rouge">arg0</code>、<code class="language-plaintext highlighter-rouge">arg1</code>这样的。有些场景例如MyBatis这种通过反射来获取Mapper接口上方法参数然后映射到XML的SQL语句上，就没法直接用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Mapper</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SomeMapper</span> <span class="o">{</span>
    <span class="nc">SomePojo</span> <span class="nf">selectOne</span><span class="o">(</span><span class="nc">String</span> <span class="n">nickName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">mobile</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>XML文件如下：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">"selectOne"</span> <span class="na">resultMap=</span><span class="s">"resultMap"</span><span class="nt">&gt;</span>
    SELECT * FROM `some_table` WHERE nick_name = #{nickName} AND mobile = #{mobile};
<span class="nt">&lt;/select&gt;</span>
</code></pre></div></div>

<p>MyBatis通过反射获取到的参数名称其实是：<code class="language-plaintext highlighter-rouge">nickName -&gt; arg0</code>、<code class="language-plaintext highlighter-rouge">mobile -&gt; arg1</code> 这样就没法正确映射到XML的SQL中<code class="language-plaintext highlighter-rouge">#{nickName}</code>、<code class="language-plaintext highlighter-rouge">#{mobile}</code>。</p>

<p>所以需要使用<code class="language-plaintext highlighter-rouge">@Param</code>注解来告诉MyBatis参数的真实名称，MyBatis才能正确映射参数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Mapper</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SomeMapper</span> <span class="o">{</span>
    <span class="nc">SomePojo</span> <span class="nf">selectOne</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"nickName"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">nickName</span><span class="o">,</span> <span class="nd">@Param</span><span class="o">(</span><span class="s">"mobile"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">mobile</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>JDK1.8之后，除了通过在参数上打注解的方式，Java原生的反射机制新增了一个类用于描述方法上的参数：<code class="language-plaintext highlighter-rouge">java.lang.reflect.Parameter</code>。我们可以直接通过这个反射类获取到方法参数的真实名称。</p>

<p>前提是我们需要在编译的时候加入<code class="language-plaintext highlighter-rouge">-parameter</code>参数，让编译器在编译类的时候将方法的参数名称也打包到<code class="language-plaintext highlighter-rouge">.class</code>文件里面。默认情况下<code class="language-plaintext highlighter-rouge">-parameter</code>是关闭的，如果需要此功能，需要手动开启：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;plugin&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>3.8.1<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;configuration&gt;</span>
        <span class="nt">&lt;compilerArgs&gt;</span>
            <span class="nt">&lt;compilerArg&gt;</span>-parameters<span class="nt">&lt;/compilerArg&gt;</span>
        <span class="nt">&lt;/compilerArgs&gt;</span>
    <span class="nt">&lt;/configuration&gt;</span>
<span class="nt">&lt;/plugin&gt;</span>
</code></pre></div></div>

<p>这样之后，就算我们不在参数上打<code class="language-plaintext highlighter-rouge">@Param</code>注解，MyBatis也能获取到真实的参数名称<code class="language-plaintext highlighter-rouge">nickName</code>和<code class="language-plaintext highlighter-rouge">mobile</code>。</p>

<hr />

<p>参考：</p>

<ul>
  <li><a href="https://www.cnblogs.com/kancy/p/10205036.html" target="_blank">https://www.cnblogs.com/kancy/p/10205036.html</a></li>
  <li><a href="https://blog.csdn.net/xiewenfeng520/article/details/102515413" target="_blank">https://blog.csdn.net/xiewenfeng520/article/details/102515413</a></li>
  <li><a href="https://www.jianshu.com/p/4f1f7a9d595f" target="_blank">https://www.jianshu.com/p/4f1f7a9d595f</a></li>
</ul>
</content>
      <pubDate>Mon, 04 Jan 2021 08:55:34 +0000</pubDate>
      <gui>/2021/01/04/java-reflection-get-method-parameter-real-name.html</gui>
    </item>
  
    <item>
      <title>Spring事务为何没有生效？</title>
      <link>/2020/09/04/spring-transaction-does-not-work.html</link>
      <content><p>最近在Review业务方的代码时发现使用了Spring事务：func方法中调用了save方法</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="nc">PojoDO</span> <span class="nf">func</span><span class="o">(</span><span class="nc">PojoDTO</span> <span class="n">pojoDTO</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span> 
    <span class="k">return</span> <span class="nf">save</span><span class="o">(</span><span class="n">pojoDTO</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>save方法是一个事务方法，打了<code class="language-plaintext highlighter-rouge">@Transactional</code>注解：期望发生异常时自动回滚数据库</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span><span class="o">(</span><span class="n">rollbackFor</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Exception</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="nc">PojoDO</span> <span class="nf">save</span><span class="o">(</span><span class="nc">PojoDTO</span> <span class="n">pojoDTO</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span> <span class="n">some</span> <span class="n">db</span> <span class="n">ops</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>先给出结论：在func方法中直接通过调用save方法的方式，会导致save方法的事务不生效，发生异常时也不会回滚。这种事务方法的调用方式是错误的。</p>

<h5 id="为什么事务会失效">为什么事务会失效？</h5>

<p>首先要知道，Spring事务本质就是通过动态代理给我们的事务方法织入异常处理的逻辑，并在发生异常时执行<code class="language-plaintext highlighter-rouge">ROLLBACK</code>回滚数据库状态。例如我们有个OrderService接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderServiceImpl</span> <span class="kd">implements</span> <span class="nc">OrderService</span> <span class="o">{</span>
    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">rollbackFor</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Exception</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span> <span class="n">some</span> <span class="n">db</span> <span class="n">ops</span> <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Spring在启动的时候扫描到<code class="language-plaintext highlighter-rouge">@Service</code>注解，会为类创建实例对象并加入到IoC容器中。但是由于Spring扫描到OrderServiceImpl的createOrder方法上有<code class="language-plaintext highlighter-rouge">@Transactional</code>注解，于是Spring框架知道这是一个事务方法，所以会为OrderServiceImpl生成一个代理类来拦截OrderServiceImpl中的所有方法并将该代理类实例添加到IoC容器中。</p>

<p>所以我们在<code class="language-plaintext highlighter-rouge">@Autowired</code>这个OrderService的时候，实际上拿到的是OrderServiceImpl的代理类的实例，而不是OrderServiceImpl类的实例：</p>

<p><img src="/static/image/2020-09/proxy-instance.png" alt="proxy-instance.png" /></p>

<p>因为createOrder上有<code class="language-plaintext highlighter-rouge">@Transactional</code>注解，所以Spring在代理类中对这个方法进行了增强：在反射调用invoke进行<code class="language-plaintext highlighter-rouge">try...catch</code>，并在catch到异常的时候进行数据库<code class="language-plaintext highlighter-rouge">ROLLBACK</code>操作。</p>

<p>所以Spring事务的是否生效，取决于我们是否是通过「代理类的对象实例」来进行方法的调用。例如最上面提到的例子，直接在<code class="language-plaintext highlighter-rouge">func</code>方法中调用了事务方法<code class="language-plaintext highlighter-rouge">save</code>，这种调用方式是不会走代理调用的，所以事务也根本不会生效。我们应该通过<code class="language-plaintext highlighter-rouge">xxxService.method</code>这种调用方式，才能使事务生效：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderServiceImpl</span> <span class="kd">implements</span> <span class="nc">OrderService</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">OrderService</span> <span class="n">orderService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">orderService</span><span class="o">.</span><span class="na">createOrder</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">rollbackFor</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Exception</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span> <span class="n">some</span> <span class="n">db</span> <span class="n">ops</span> <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>因为<code class="language-plaintext highlighter-rouge">@Autowired private OrderService orderService;</code>注入的是代理类对象，所以在使用<code class="language-plaintext highlighter-rouge">orderService.createOrder()</code>调用时能正确走到事务的逻辑。</p>

<p>除了<code class="language-plaintext highlighter-rouge">xxxService.method</code>这种调用方式，我们也可以通过<code class="language-plaintext highlighter-rouge">@EnableAspectJAutoProxy</code>注解，将代理类暴露到ThreadLocal中，然后通过<code class="language-plaintext highlighter-rouge">AopContext.currentProxy()</code>来获取当前类的代理对象：</p>

<p><img src="/static/image/2020-09/enableAspectJAutoProxy.png" alt="enableAspectJAutoProxy.png" />
<img src="/static/image/2020-09/aop-context.png" alt="aop-context.png" /></p>

<p><strong>但是注意，<code class="language-plaintext highlighter-rouge">@EnableAspectJAutoProxy(exposeProxy = true)</code>不能保证一定能够正确工作：</strong></p>

<p><img src="/static/image/2020-09/EnableAspectJAutoProxy-exposeProxy.png" alt="EnableAspectJAutoProxy-exposeProxy.png" /></p>

<p>如果直接调用<code class="language-plaintext highlighter-rouge">createOrder()</code>就没有走代理，直接走的普通方法调用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderServiceImpl</span> <span class="kd">implements</span> <span class="nc">OrderService</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">OrderService</span> <span class="n">orderService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">createOrder</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">rollbackFor</span> <span class="o">=</span> <span class="o">{</span><span class="nc">Exception</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span> <span class="n">some</span> <span class="n">db</span> <span class="n">ops</span> <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这样一来，Spring的事务就失效了。没有正确走代理调用是Spring事务不起作用的情况之一。</p>

<p>我们在使用Spring事务的时候，想要使Spring事务正常工作，可能还需要注意以下几点：</p>

<ul>
  <li>包含<code class="language-plaintext highlighter-rouge">@Transactional</code>注解的类必须要被Spring IoC容器管理，否则Spring没法扫描到该Bean为其生成代理类；</li>
  <li>要为数据源配置「事务管理器」：PlatformTransactionManager；</li>
  <li>要确保我们的数据库操作的表是支持事务的，例如InnoDB支持事务，而MyISAM的数据表就不支持事务；</li>
  <li>方法的异常不能自己try…catch消化掉，否则Spring事务没法感知到你的方法抛了异常，也就不会回滚；</li>
  <li>事务的rollbackFor异常类型配置错误，例如配置rollbackFor=SQLException.class，但是你在方法中却抛出BuzzException.class异常，异常类型不匹配也无法让Spring事务感知到；</li>
  <li>Spring事务传播机制要配置正确，例如：</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">Test</span> <span class="n">test</span><span class="o">;</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method1</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">test</span><span class="o">.</span><span class="na">method2</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">NOT_SUPPORTED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method2</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">..</span> <span class="n">some</span> <span class="n">db</span> <span class="n">ops</span> <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>method2的事务传播机制是<code class="language-plaintext highlighter-rouge">Propagation.NOT_SUPPORTED</code>，即不支持事务。如果当前存在事务，它会挂起当前事务，并以非事务的方式执行method2。执行完method2再恢复method1的事务。在这个例子中，method2就不会以事务方式执行，发生异常也不会回滚method2中涉及到的数据库操作。</p>

<hr />

</content>
      <pubDate>Fri, 04 Sep 2020 03:36:26 +0000</pubDate>
      <gui>/2020/09/04/spring-transaction-does-not-work.html</gui>
    </item>
  
    <item>
      <title>Redis缓存雪崩/穿透/击穿</title>
      <link>/2020/07/30/redis-caching-problems.html</link>
      <content><h3 id="1-redis缓存雪崩">1. Redis缓存雪崩</h3>

<p>当缓存服务器宕机或者大量缓存key同时（或者说集中在某个时间段）过期了，大量的请求会在短时间内直接打到DB上，导致DB压力过大，严重的可能会造成DB挂掉。这种情况叫做缓存雪崩。</p>

<p>针对Redis缓存雪崩，解决方案如下：</p>

<ol>
  <li>生产环境避免单机Redis，做集群高可用，主从+哨兵，Redis cluster，避免缓存全线崩盘。</li>
  <li>Redis开启持久化，发生宕机重启之后快速恢复数据。</li>
  <li>采用多级缓存：本地缓存 + hystrix限流&amp;降级，避免一级Redis缓存不可用导致DB被压垮。请求进来先查本地缓存，本地缓存没命中再查Redis，两级缓存都没有再查DB。同时还可以针对服务接口能力做限流&amp;降级处理，如果请求QPS超过了服务接口本身所能承受的数量，走服务降级，例如直接返回一些默认值、友好提示或者空白页面等。</li>
  <li>针对大量缓存key同时过期的情况，简单的做法就是在每个key基础过期时间之上加一个随机值，例如1~5分钟的随机时间，让key的过期时间尽量分散。</li>
</ol>

<h3 id="2-redis缓存击穿">2. Redis缓存击穿</h3>

<p>某个非常热点的key，访问非常频繁，处于高并发访问的情况。在这个key过期的瞬间，大量请求直接打到DB上造成DB压力很大。这种情况叫做缓存击穿。</p>

<p>针对Redis缓存击穿，解决方案如下：</p>

<ol>
  <li>对load DB的操作加互斥锁（mutex），保证只有一个线程去查数据库并将数据更新到缓存中。其他请求进来，抢不到锁可以循环等待一段时间再重试。</li>
  <li>热点数据设置永不过期。永不过期可以有两层意思：「物理」不过期，实际没有设置过期时间；「逻辑」不过期，redis设置某个key的时候不设置过期时间，但是会通过另一个timeKey来维护这个key的过期时间。每次查询key都会先查询timeKey，如果发现快过期或者已过期，就通过后台线程去更新这个value。这种做法可能会存在短暂的数据不一致，但是可以做得“很平滑”，不会阻塞用户请求，用户体验很好。</li>
</ol>

<h3 id="3-redis缓存穿透">3. Redis缓存穿透</h3>

<p>缓存穿透是指请求一些一定不存在的key，请求会直接打到DB上。有些人利用这些系统中不存在的key进行恶意请求攻击。解决方案如下：</p>

<ol>
  <li>采用布隆过滤器对系统中所有数据哈希到一个足够大的bitmap中，Redis的bitmap数据结构就很合适。请求进来会先经过布隆过滤器，过滤掉一些恶意请求。</li>
  <li>采用空值缓存：如果缓存没命中，再去查询DB，DB也没命中说明数据库中不存在这条数据。这时可以构建一个空值保存到缓存中，设置一个较小的过期时间（例如5分钟），这样可以有效过滤恶意请求，保护DB。</li>
</ol>

<hr />

</content>
      <pubDate>Thu, 30 Jul 2020 04:09:20 +0000</pubDate>
      <gui>/2020/07/30/redis-caching-problems.html</gui>
    </item>
  
    <item>
      <title>无网络环境下使用阿里arthas诊断工具</title>
      <link>/2020/07/27/arthas-run-without-network.html</link>
      <content><p>最近排查一个线上问题，有个第三方公司服务启动后，访问的时候总是报数据库连接失败。由于是第三方服务，没法增加一些日志进行观察，所以使用阿里的arthas在线诊断工具进行排查。服务部署在客户的机房中，不允许连接外部网络，所以手动下载<code class="language-plaintext highlighter-rouge">arthas-boot.jar</code>并通过<code class="language-plaintext highlighter-rouge">scp</code>方式上传到目标机器的方式去运行。</p>

<p>根据<a href="https://alibaba.github.io/arthas/install-detail.html" target="_blank">arthas官网安装教程</a>，下载<code class="language-plaintext highlighter-rouge">arthas-boot.jar</code>，然后<code class="language-plaintext highlighter-rouge">scp</code>上传到目标主机（客户的机器）：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-O</span> https://alibaba.github.io/arthas/arthas-boot.jar
<span class="nv">$ </span>scp <span class="nt">-rp</span> arthas-boot.jar appweb@192.168.100.4:/appweb/
</code></pre></div></div>

<p>执行<code class="language-plaintext highlighter-rouge">java -jar arthas-boot.jar</code>，运行结果如下图所示：</p>

<p><img src="/static/image/2020/arthas-run.png" alt="arthas-run" /></p>

<p>原来<code class="language-plaintext highlighter-rouge">arthas-boot.jar</code>并不是全量包，它会在启动的时候先去阿里Maven仓库下载一些jar包依赖；如果Maven下载失败，那么它会检查本地是否有jar包依赖文件，例如图中的日志：</p>

<p><code class="language-plaintext highlighter-rouge">[ERROR] Can not find Arthas under local: /root/.arthas/lib</code></p>

<p>所以解决方案可以这样：在我的机器上（可联外网），先运行<code class="language-plaintext highlighter-rouge">java -jar arthas-boot.jar</code>下载得到一个<code class="language-plaintext highlighter-rouge">.arthars</code>文件夹，里面存放的就是arthas-boot.jar所需的一些jar包依赖。<code class="language-plaintext highlighter-rouge">.arthars</code>文件夹会默认在用户主目录下生成。</p>

<p>最后将<code class="language-plaintext highlighter-rouge">.arthas</code>文件夹也<code class="language-plaintext highlighter-rouge">scp</code>传送到客户的目标机器，即可完成。</p>

<hr />

</content>
      <pubDate>Mon, 27 Jul 2020 07:20:00 +0000</pubDate>
      <gui>/2020/07/27/arthas-run-without-network.html</gui>
    </item>
  
    <item>
      <title>Linux时间/时区设置</title>
      <link>/2020/07/27/timezone-settings.html</link>
      <content><p>Linux中设置时间为东八区时间（北京时间）：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ln</span> <span class="nt">-sf</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'Asia/Shanghai'</span> <span class="o">&gt;</span> /etc/timezone
<span class="nv">$ </span><span class="nb">date</span> <span class="nt">-R</span>
Mon, 27 Jul 2020 14:12:04 +0800
</code></pre></div></div>

<p>/etc/localtime文件描述的是本机时间；/etc/timezone文件描述的是本机所属的时区。/usr/share/zoneinfo目录下面存放的是全球各个时区/时间的文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> /usr/share/zoneinfo
Africa      Atlantic   Chile    Eire     Factory  GMT-0      Iceland      Jamaica            
America     Australia  CST6CDT  EST      GB       GMT+0      Indian       Japan             
Antarctica  Brazil     Cuba     EST5EDT  GB-Eire  Greenwich  Iran         Kwajalein
...
</code></pre></div></div>

<p>有时候在构建Docker镜像的时候，运行之后发现时间是UTC时间。这时可以在<code class="language-plaintext highlighter-rouge">Dockerfile</code>文件中加入以下内容来设置镜像运行时的时区为东八区：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RUN <span class="nb">ln</span> <span class="nt">-sf</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
RUN <span class="nb">echo</span> <span class="s1">'Asia/Shanghai'</span> <span class="o">&gt;</span> /etc/timezone
</code></pre></div></div>

<p>如果是Java应用，通过<code class="language-plaintext highlighter-rouge">echo 'Asia/Shanghai' &gt; /etc/timezone</code>已经正确设置了时区为东八区，那么代码里面就不需要对时区进行设置：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TimeZone</span> <span class="n">timeZone</span> <span class="o">=</span> <span class="nc">TimeZone</span><span class="o">.</span><span class="na">getTimeZone</span><span class="o">(</span><span class="s">"Asia/Shanghai"</span><span class="o">);</span>
<span class="nc">TimeZone</span><span class="o">.</span><span class="na">setDefault</span><span class="o">(</span><span class="n">timeZone</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<p>参考：</p>
<ul>
  <li><a href="https://blog.csdn.net/alinyua/article/details/80944543">https://blog.csdn.net/alinyua/article/details/80944543</a></li>
</ul>
</content>
      <pubDate>Mon, 27 Jul 2020 06:08:45 +0000</pubDate>
      <gui>/2020/07/27/timezone-settings.html</gui>
    </item>
  
    <item>
      <title>Redis持久化之rdb和aof</title>
      <link>/2020/06/01/redis-persistence.html</link>
      <content><p>Redis虽然是内存数据库，但是为了一定程度的数据可靠性也做了一些持久化的方案，确保Redis机器宕机或者断电重启之后，能从备份数据中恢复宕机、掉电前的数据。</p>

<p>Redis目前有两种持久化方案：RDB持久化和AOF持久化。</p>

<h3 id="1-redis-rdb持久化">1. Redis RDB持久化</h3>

<p>RDB全称是Redis DataBase。是Redis最早支持的一种持久化方式，也是Redis默认的持久化方案。</p>

<p>RDB持久化是一种生成「快照」数据的方式，它会根据配置文件（<code class="language-plaintext highlighter-rouge">redis.conf</code>）中的持久化策略在合适的时机自动去dump整个Redis服务器在「某个时刻」的中的全量内存数据，即某个时刻的快照数据。并将快照数据保存在一个名叫<code class="language-plaintext highlighter-rouge">dump.rdb</code>的文件中，这些快照数据以二进制格式压缩存储。</p>

<h5 id="11-rdb持久化策略配置">1.1 RDB持久化策略配置</h5>

<p>我们可以在Redis服务器的配置文件中以<code class="language-plaintext highlighter-rouge">save</code>指令配置RDB持久化策略，如下所示：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># redis.conf
# save &lt;seconds&gt; &lt;changes&gt;

save 900 1     # 900秒（15分钟）内，如果至少有一个key被更改则触发RDB
save 300 10    # 300秒（5分钟）内，如果至少有一个key被更改则触发RDB
save 60 10000  # 60秒内，如果至少发生10000个key被更改则触发RDB
</code></pre></div></div>

<p>如果想关闭RDB持久化，只需要将配置文件中的save配置项改成：<code class="language-plaintext highlighter-rouge">save ""</code>即可：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># redis.conf
# save &lt;seconds&gt; &lt;changes&gt;

save ""  # save "" 表示关闭RDB持久化
</code></pre></div></div>

<h5 id="12-rdb持久化手动触发执行">1.2 RDB持久化手动触发执行</h5>

<p>写在redis.conf文件中的<code class="language-plaintext highlighter-rouge">save &lt;seconds&gt; &lt;changes&gt;</code>配置项可以让Redis自动触发RDB持久化。但是有时候我们也可能需要手动触发一下RDB持久化，这时候可以使用以下两条Redis命令：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SAVE</code>：SAVE命令直接在当前Redis进程中执行RDB持久化操作，会阻塞掉来自客户端的所有请求，直到RDB持久化完成。<strong>生产环境慎用！</strong></li>
  <li><code class="language-plaintext highlighter-rouge">BGSAVE</code>：BGSAVE命令会调用fork创建一个子进程来进行RDB持久化操作。fork完毕之后，子进程会在后台进行RDB持久化，不会影响Redis主进程处理客户端的请求。</li>
</ul>

<blockquote>
  <p>生产环境手动触发RDB持久化，首选BGSAVE命令。若BGSAVE产生的后台子进程出现问题时，则可以考虑用SAVE命令来兜底。</p>
</blockquote>

<h5 id="13-rdb快照数据的恢复">1.3 RDB快照数据的恢复</h5>

<p>Redis启动时，若发现数据目录下有<code class="language-plaintext highlighter-rouge">dump.rdb</code>文件就会自动加载该文件中的数据内容到内存中。</p>

<p><img src="/static/image/2020/rdb-load.png" alt="rdb-load.png" /></p>

<p><code class="language-plaintext highlighter-rouge">dump.rdb</code>记录的就是某个时刻Redis服务器内存中的全量物理数据，并以二进制格式压缩存储。所以加载到内存也就完成了数据的恢复。</p>

<h5 id="14-rdb持久化方式总结">1.4 RDB持久化方式总结</h5>

<p>RDB持久化方式关注点在于<strong>快照数据</strong>，每次触发RDB持久化都是全量保存某个时间点上的所有内存数据。就这一点而言，它很适合备份场景，用于灾难恢复。它有如下优点：</p>

<ul>
  <li>RDB持久化生成的<code class="language-plaintext highlighter-rouge">dump.rdb</code>文件是一个经过压缩的紧凑的二进制文件，加载/恢复速度很快。</li>
</ul>

<p>RDB持久化也有缺点：</p>

<ul>
  <li>没法做到实时/秒级持久化，因为每次RDB持久化都会fork一个子进程来生成快照数据，fork属于重量级操作，频繁fork会让cpu和内存吃不消，影响Redis性能。</li>
</ul>

<h3 id="2-redis-aof持久化">2. Redis AOF持久化</h3>

<p>Redis <code class="language-plaintext highlighter-rouge">v1.1</code>开始支持另一种持久化方式：AOF（<code class="language-plaintext highlighter-rouge">Append-only File</code>）。相比RDB持久化记录物理数据的方式，AOF文件记录的不是物理数据，而是记录Redis中的每条<strong>写命令</strong>，例如<code class="language-plaintext highlighter-rouge">SET</code>，<code class="language-plaintext highlighter-rouge">DEL</code>等。每当有写操作发生，这个写操作的命令会被追加到AOF文件中：<code class="language-plaintext highlighter-rouge">appendonly.aof</code>。</p>

<p>我们可以这么理解：RDB记录的是物理日志，AOF记录的是逻辑日志，是一条条Redis写操作命令。</p>

<blockquote>
  <p>这个有点类似MySQL中的redo log和binlog。redo log记录的也是物理日志，binlog记录的是一条条SQL，是逻辑日志。</p>
</blockquote>

<h5 id="21-aof持久化策略配置">2.1 AOF持久化策略配置</h5>

<p>Redis默认不开启AOF持久化，我们需要在<code class="language-plaintext highlighter-rouge">redis.conf</code>配置文件中配置<code class="language-plaintext highlighter-rouge">appendonly yes</code>来开启：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># redis.conf
appendonly yes        # yes表示开启AOF持久化；no表示关闭AOF持久化
appendfsync everysec  # AOF持久化策略：no、always、everysec
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">appendfsync</code>参数对Redis的性能有着重要的影响：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">always</code>：每次写操作都会调用fsync将写操作命令同步到磁盘的<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件中，这种方式性能最差，但是数据可靠性最强；</li>
  <li><code class="language-plaintext highlighter-rouge">no</code>：每次Redis写操作后不会主动调用fsync同步到磁盘，只是写入缓冲区，由操作系统内核自动将缓冲区数据持久化到磁盘。Linux内核默认以每「30秒/次」的频率将文件缓冲区的数据刷新到磁盘。这种方式性能最好，但是数据可靠性最差；</li>
  <li><code class="language-plaintext highlighter-rouge">everysec</code>：everysec是权衡了性能和数据可靠性之后的一种折衷方式，即由Redis后台线程每秒调用fsync将缓冲区数据持久化到磁盘。这种方式兼顾了性能和数据的可靠性，是AOF默认的配置方式。采用这种方式，遇到宕机或者掉电我们最多丢失1秒的数据。</li>
</ul>

<h5 id="22-aof数据的加载恢复">2.2 AOF数据的加载恢复</h5>

<p>如果同时开启RDB和AOF持久化，即数据目录中会同时存在<code class="language-plaintext highlighter-rouge">dump.rdb</code>和<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件，Redis在启动的时候会优先使用<code class="language-plaintext highlighter-rouge">appendonly.aof</code>来恢复数据，因为从AOF文件中恢复的数据集是最完整也是最新的。同样，在启动日志中体现了AOF文件的加载：</p>

<p><img src="/static/image/2020/aof-load.png" alt="aof-load.png" /></p>

<p>不像RDB数据的恢复，直接load到内存即可。AOF的恢复需要读取<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件并逐条执行该文件中记录的每一条Redis命令来达到重建整个数据集的目的。如果数据集很大，那么AOF的恢复会比RDB慢很多。</p>

<p><code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件只是一个文本文件，里面记录着每次Redis的写操作命令。</p>

<p>例如我执行<code class="language-plaintext highlighter-rouge">SET test_key hello</code>之后，查看<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件内容如下所示：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*2
$6
SELECT
$1
0
*3
$3
SET
$8
test_key
$5
hello
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: left">字符</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">*3</td>
      <td style="text-align: left">表示此条Redis命令包含3个参数</td>
    </tr>
    <tr>
      <td style="text-align: left">$3</td>
      <td style="text-align: left">表示第一个参数的长度为3，即<code class="language-plaintext highlighter-rouge">SET</code>占用3个字符</td>
    </tr>
    <tr>
      <td style="text-align: left">$8</td>
      <td style="text-align: left">表示第二个参数的长度为8，即<code class="language-plaintext highlighter-rouge">test_key</code>占用8个字符</td>
    </tr>
    <tr>
      <td style="text-align: left">$5</td>
      <td style="text-align: left">表示第三个参数的长度为5，即<code class="language-plaintext highlighter-rouge">hello</code>占用5个字符</td>
    </tr>
  </tbody>
</table>

<p>现在我执行一个删除操作，删除刚才的key：<code class="language-plaintext highlighter-rouge">DEL test_key</code>，此时<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件内容：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*2
$6
SELECT
$1
0
*3
$3
SET
$8
test_key
$5
hello
*2
$6
SELECT
$1
0
*2
$3
DEL
$8
test_key
</code></pre></div></div>

<p>发现AOF文件除了记录我们之前的<code class="language-plaintext highlighter-rouge">SET</code>，也记录了我们的<code class="language-plaintext highlighter-rouge">DEL</code>写操作命令，这就是<code class="language-plaintext highlighter-rouge">Append-only</code>，所有的写操作命令只是追加到AOF文件中。所以当Redis宕机重启之后，加载<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件执行里面的一条条写操作命令之后，得到的数据集就是Redis宕机前的数据集，从而恢复数据。</p>

<p>若设置一个自动过期的key，AOF文件会怎样记录？例如：<code class="language-plaintext highlighter-rouge">SET ttl_key ttl_value EX 300</code>，设置<code class="language-plaintext highlighter-rouge">ttl_key</code>的过期时间为5分钟，查看<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*3
$9
PEXPIREAT
$7
ttl_key
$13
1591017706735
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SET ttl_key ttl_value EX 300</code>命令会被转换成另一种形式记录在<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件中，变成了<code class="language-plaintext highlighter-rouge">PEXPIREAT ttl_key 1591017706735</code>。这很合理，因为当重启恢复数据后，Redis重新构建这条数据的时候可能已经过期，也就会自动删除；如果AOF不做转换而是原样记录写操作命令，那么当恢复数据的时候，就有可能会产生数据不一致。</p>

<h5 id="23-aof日志重写机制">2.3 AOF日志重写机制</h5>

<p><code class="language-plaintext highlighter-rouge">appendonly.aof</code>只是一个文本文件，而且Redis写操作命令会不断地追加到文件尾部。随着时间的推移，<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件的体积会越来越大，宕机重启恢复数据时，耗时也会越来越大。所以才有了AOF日志的重写机制。</p>

<p>所谓AOF日志重写，就是将<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件中的多条指令操作合并成一条指令的操作，节省存储空间，也节省启动恢复数据的耗时。例如，多次对同一个key执行<code class="language-plaintext highlighter-rouge">INCR</code>操作，AOF文件中也会依次记录多次<code class="language-plaintext highlighter-rouge">INCR</code>。通过AOF日志重写，针对这个key的<code class="language-plaintext highlighter-rouge">INCR</code>操作可以合并成一个<code class="language-plaintext highlighter-rouge">SET</code>操作：100次<code class="language-plaintext highlighter-rouge">INCR count_key</code>可以重写成一次<code class="language-plaintext highlighter-rouge">SET count_key 100</code>。</p>

<p>AOF日志重写能保证AOF日志文件数据的安全，如何实现数据安全呢？原理如下图所示：</p>

<p><img src="/static/image/2020/aof-rewrite-flow.png" alt="aof-rewrite-flow.png" /></p>

<ul>
  <li>主进程执行fork操作，创建一个子进程；</li>
  <li>子进程遍历内存中的数据，转换成写操作命令并写入一个临时文件；</li>
  <li>客户端的实时写命令请求，主进程还是会持久化到原来的AOF文件，<strong>同时也将写命令写入一个AOF重写内存缓存中</strong>，这样即使在重写过程中发生宕机，也能确保原来的AOF文件是安全的；</li>
  <li>子进程重写完毕，给主进程发送一个通知；主进程收到通知后，将<strong>AOF内存缓存</strong>中的写操作命令追加到这个AOF临时文件中；</li>
  <li>Redis原子地将AOF临时文件重命名为<code class="language-plaintext highlighter-rouge">appendonly.aof</code>，替换原AOF文件，完成！</li>
</ul>

<p>如何触发AOF日志重写呢？</p>

<p><strong>(1) 手动触发AOF日志重写</strong></p>

<p>在Redis <code class="language-plaintext highlighter-rouge">v2.4</code>之前，只能通过<code class="language-plaintext highlighter-rouge">BGREWRITEAOF</code>命令手动触发AOF日志重写。</p>

<p><img src="/static/image/2020/aof-rewrite.png" alt="aof-rewrite.png" /></p>

<p>查看<code class="language-plaintext highlighter-rouge">appendonly.aof</code>文件发现重写之后，文件出现了<code class="language-plaintext highlighter-rouge">REDIS0009ú redis-ver^E5.0.5ú</code>字符，跟<code class="language-plaintext highlighter-rouge">dump.rdb</code>中的字符一样，说明AOF重写会对文件内容进行压缩存储。</p>

<p><strong>(2) <code class="language-plaintext highlighter-rouge">redis.conf</code>配置AOF自动重写策略</strong></p>

<p>Redis <code class="language-plaintext highlighter-rouge">v2.4</code>及之后的版本可以通过配置文件来配置AOF日志自动重写的策略。</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># redis.conf
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">auto-aof-rewrite-percentage</code>：Redis会记录上一次AOF重写之后的文件大小（如果没有执行过AOF重写，那么以Redis重启后AOF文件大小为基准），如果发现AOF文件当前大小大于上一次文件大小的指定百分比，例如上一次重写之后文件大小为<code class="language-plaintext highlighter-rouge">100MB</code>，指定百分比为<code class="language-plaintext highlighter-rouge">100%</code>，那么当前文件大小大于<code class="language-plaintext highlighter-rouge">100MB + 100MB*100% = 200MB</code>的时候，就会触发AOF重写；</li>
  <li><code class="language-plaintext highlighter-rouge">auto-aof-rewrite-min-size</code>：这个参数是指定触发AOF重写的AOF文件大小的最小值，超过这个值才会触发AOF重写；如果AOF文件大小小于这个值，就算超过了<code class="language-plaintext highlighter-rouge">auto-aof-rewrite-percentage</code>百分比，也不会触发重写。</li>
</ul>

<h5 id="24-aof日志文件损坏怎么办">2.4 AOF日志文件损坏怎么办？</h5>

<p>Redis在运行过程中可能会遇到突发的宕机、停电，如果这时候正在写AOF文件，就有可能没写完成，发生文件损坏（corrupt）。Redis在重启之后，发现AOF文件损坏会拒绝加载这个AOF文件。这个时候可以这样做：</p>

<ul>
  <li>先为现有的AOF文件创建一个备份，备份很重要；</li>
  <li>使用Redis自带的程序工具<code class="language-plaintext highlighter-rouge">redis-check-aof</code>对损坏的AOF文件进行修复：<code class="language-plaintext highlighter-rouge">redis-check-aof --fix appendonly.aof</code>；</li>
  <li>（可选）使用<code class="language-plaintext highlighter-rouge">diff -u</code>对比修复后的文件和原始文件的备份，查看两个文件之间的不同之处；</li>
  <li>重启Redis，等待Redis重新加载AOF文件进行数据恢复。</li>
</ul>

<h5 id="25-aof持久化方式总结">2.5 AOF持久化方式总结</h5>

<p>AOF持久化保存的是一种逻辑日志，即记录的是一条条写操作的命令，而不是像RDB持久化那样记录物理数据。它在恢复数据的时候，是直接执行AOF文件中的一条条Redis命令来重建整个数据集的。</p>

<p>AOF持久化的优点：</p>

<ul>
  <li>能够做到实时/秒级别的持久化，数据的实时性更好。</li>
</ul>

<p>AOF持久化优点：</p>

<ul>
  <li>AOF文件体积会比RDB大，如果数据集很大，AOF重写和AOF文件加载/恢复都将是一个很耗资源和耗时的操作。</li>
</ul>

<h3 id="3-写在最后">3. 写在最后</h3>

<p>Redis的两种持久化方式各有特色，我们生产环境一般不会只用其中一种，而是同时使用两种。</p>

<p>例如RDB可以结合<code class="language-plaintext highlighter-rouge">cron</code>定时任务去定期生成备份数据，用于灾难恢复；同时，AOF因为支持实时持久化，它记录的数据集是最实时的，所以我们也会同时开启AOF持久化，应对一些对数据实时完整性要求较高的场景。但是AOF也可能会损坏无法修复，所以两种方式并用对数据才是最安全的。</p>

<hr />

</content>
      <pubDate>Mon, 01 Jun 2020 12:14:31 +0000</pubDate>
      <gui>/2020/06/01/redis-persistence.html</gui>
    </item>
  
    <item>
      <title>MySQL INSERT IGNORE INTO</title>
      <link>/2020/05/30/sql-insert-ignore.html</link>
      <content><p>开发中经常会一次性往一个里INSERT多条数据，但是当某条INSERT SQL因为与表中发生<strong>主键冲突</strong>，或者与某个定义为<code class="language-plaintext highlighter-rouge">UNIQUE KEY</code>的字段发生<code class="language-plaintext highlighter-rouge">Duplicate entry</code>错误时，MySQL会放弃执行后续的INSERT SQL。而我们希望如果某条INSERT发生了唯一性约束的错误，那么这条INSERT不插入数据即可，不要影响后面的其他INSERT语句的执行。</p>

<h3 id="1-需求描述">1. 需求描述</h3>

<p>有张表的结构如下所示：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`my_user`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="nb">unsigned</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span> <span class="k">COMMENT</span> <span class="s1">'自增ID'</span><span class="p">,</span>
  <span class="nv">`nickname`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'用户昵称'</span><span class="p">,</span>
  <span class="nv">`mobile`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'手机号码'</span><span class="p">,</span>
  <span class="nv">`email`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'邮箱地址'</span><span class="p">,</span>
  <span class="nv">`address`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'居住地址'</span><span class="p">,</span>
  <span class="nv">`age`</span> <span class="nb">tinyint</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="nb">unsigned</span> <span class="k">DEFAULT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'用户年龄'</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="k">KEY</span> <span class="nv">`uk_nickname`</span> <span class="p">(</span><span class="nv">`nickname`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span> <span class="k">COMMENT</span><span class="o">=</span><span class="s1">'用户表'</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>id字段为主键；在nickname字段处创建了唯一索引。</p>
</blockquote>

<p>当往表里一次性插入多条数据，前两条数据数据的id值都为1：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'zhangsan'</span><span class="p">,</span> <span class="s1">'17777778901'</span><span class="p">,</span> <span class="s1">'zhangsan@foxmail.com'</span><span class="p">,</span> <span class="s1">'Beijing'</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'lisi'</span><span class="p">,</span> <span class="s1">'16688990101'</span><span class="p">,</span> <span class="s1">'lisi@foxmail.com'</span><span class="p">,</span> <span class="s1">'Hangzhou'</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'wangwu'</span><span class="p">,</span> <span class="s1">'155784983939'</span><span class="p">,</span> <span class="s1">'wangwu@foxmail.com'</span><span class="p">,</span> <span class="s1">'Guangxi'</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>

<p>会出现主键冲突错误：</p>

<blockquote>
  <p>ERROR 1062 (23000): Duplicate entry ‘1’ for key ‘PRIMARY’</p>
</blockquote>

<p>同样，往表里一次性插入多条数据，前面两条数据的nickname都为<code class="language-plaintext highlighter-rouge">zhangsan</code>。需要注意的是，nickname字段是有唯一索引约束的。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'zhangsan'</span><span class="p">,</span> <span class="s1">'17777778901'</span><span class="p">,</span> <span class="s1">'zhangsan@foxmail.com'</span><span class="p">,</span> <span class="s1">'Beijing'</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'zhangsan'</span><span class="p">,</span> <span class="s1">'16688990101'</span><span class="p">,</span> <span class="s1">'lisi@foxmail.com'</span><span class="p">,</span> <span class="s1">'Hangzhou'</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'wangwu'</span><span class="p">,</span> <span class="s1">'155784983939'</span><span class="p">,</span> <span class="s1">'wangwu@foxmail.com'</span><span class="p">,</span> <span class="s1">'Guangxi'</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>

<p>同样也会出现唯一性约束错误：</p>

<blockquote>
  <p>ERROR 1062 (23000): Duplicate entry ‘zhangsan’ for key ‘uk_username’</p>
</blockquote>

<p>以上两种出现唯一性约束错误之后，MySQL就不会执行后续的INSERT SQL，例如上面的<code class="language-plaintext highlighter-rouge">wangwu</code>就不会被执行。在批量执行INSERT SQL时，如何忽略某些INSERT操作发生的唯一性约束异常，而不影响后续的INSERT SQL的执行呢？这里记录两种实现方式。</p>

<h3 id="2-使用insert-ignore-into">2. 使用<code class="language-plaintext highlighter-rouge">INSERT IGNORE INTO</code></h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">IGNORE</code>子句是MySQL对SQL标准的扩展。</p>
</blockquote>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">IGNORE</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'zhangsan'</span><span class="p">,</span> <span class="s1">'17777778901'</span><span class="p">,</span> <span class="s1">'zhangsan@foxmail.com'</span><span class="p">,</span> <span class="s1">'Beijing'</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">IGNORE</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'zhangsan'</span><span class="p">,</span> <span class="s1">'16688990101'</span><span class="p">,</span> <span class="s1">'lisi@foxmail.com'</span><span class="p">,</span> <span class="s1">'Hangzhou'</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">IGNORE</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'wangwu'</span><span class="p">,</span> <span class="s1">'155784983939'</span><span class="p">,</span> <span class="s1">'wangwu@foxmail.com'</span><span class="p">,</span> <span class="s1">'Guangxi'</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>

<p>已知nickname字段上有唯一索引约束，现在每条INSERT SQL都加上了<code class="language-plaintext highlighter-rouge">IGNORE</code>，如果用户昵称已经存在，就不执行插入；否则执行插入。这样就不会影响后续的INSERT SQL的执行。</p>

<h3 id="3-使用insert-into--on-duplicate-key-update">3. 使用<code class="language-plaintext highlighter-rouge">INSERT INTO ... ON DUPLICATE KEY UPDATE</code></h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'zhangsan'</span><span class="p">,</span> <span class="s1">'17777778901'</span><span class="p">,</span> <span class="s1">'zhangsan@foxmail.com'</span><span class="p">,</span> <span class="s1">'Beijing'</span><span class="p">,</span> <span class="mi">18</span><span class="p">)</span> <span class="k">ON</span> <span class="n">DUPLICATE</span> <span class="k">KEY</span> <span class="k">UPDATE</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'zhangsan'</span><span class="p">,</span> <span class="s1">'16688990101'</span><span class="p">,</span> <span class="s1">'lisi@foxmail.com'</span><span class="p">,</span> <span class="s1">'Hangzhou'</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span> <span class="k">ON</span> <span class="n">DUPLICATE</span> <span class="k">KEY</span> <span class="k">UPDATE</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_user</span> <span class="p">(</span><span class="n">nickname</span><span class="p">,</span> <span class="n">mobile</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'wangwu'</span><span class="p">,</span> <span class="s1">'155784983939'</span><span class="p">,</span> <span class="s1">'wangwu@foxmail.com'</span><span class="p">,</span> <span class="s1">'Guangxi'</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="k">ON</span> <span class="n">DUPLICATE</span> <span class="k">KEY</span> <span class="k">UPDATE</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">INSERT INTO ... ON DUPLICATE KEY UPDATE</code>作用是，若INSERT发生了唯一性约束错误，那么就执行该条记录的更新操作；若没有发生唯一性约束错误，说明记录还未存在，直接执行插入操作。</p>

<hr />

</content>
      <pubDate>Sat, 30 May 2020 03:44:51 +0000</pubDate>
      <gui>/2020/05/30/sql-insert-ignore.html</gui>
    </item>
  
    <item>
      <title>Java获取HTTP请求中客户端真实IP</title>
      <link>/2020/03/13/IpUtils.html</link>
      <content><p>Web服务器端获取HTTP请求客户端的真实IP地址工具类，点击下载：<a href="/static/files/IpUtils.java" download="IpUtils.java">IpUtils.java</a></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.NetworkInterface</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.SocketException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Enumeration</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">IpUtils</span> <span class="o">{</span>

    <span class="cm">/**
     * 请求通过反向代理之后，可能包含请求客户端真实IP的HTTP HEADER
     * 如果后续扩展，有其他可能包含IP的HTTP HEADER，加到这里即可
     */</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="no">POSSIBLE_HEADERS</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span>
            <span class="s">"X-Forwarded-For"</span><span class="o">,</span> <span class="s">"X-Real-IP"</span><span class="o">,</span> <span class="s">"Proxy-Client-IP"</span><span class="o">,</span>
            <span class="s">"WL-Proxy-Client-IP"</span><span class="o">,</span> <span class="s">"HTTP_CLIENT_IP"</span><span class="o">,</span> <span class="s">"HTTP_X_FORWARDED_FOR"</span>
    <span class="o">};</span>

    <span class="kd">private</span> <span class="nf">IpUtils</span><span class="o">()</span> <span class="o">{}</span>

    <span class="cm">/**
     * 获取请求客户端的真实IP地址
     * @param request javax.servlet.http.HttpServletRequest
     * @return 客户端端真实IP地址
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getClientIp</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">ip</span><span class="o">;</span>
        <span class="c1">// 先检查代理：逐个HTTP HEADER检查过去，看看是否存在客户端真实IP</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">header</span> <span class="o">:</span> <span class="no">POSSIBLE_HEADERS</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ip</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="n">header</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">isNotBlank</span><span class="o">(</span><span class="n">ip</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="s">"unknown"</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">ip</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 请求经过多次反向代理后可能会有多个IP值（以英文逗号分隔），第一个IP才是客户端真实IP</span>
                <span class="k">return</span> <span class="n">ip</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">","</span><span class="o">)</span> <span class="o">?</span> <span class="n">ip</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">)[</span><span class="mi">0</span><span class="o">]</span> <span class="o">:</span> <span class="n">ip</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 从所有可能的HTTP HEADER中都没有找到客户端真实IP，采用request.getRemoteAddr()来兜底</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="s">"0:0:0:0:0:0:0:1"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ip</span><span class="o">)</span> <span class="o">||</span> <span class="s">"127.0.0.1"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ip</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 说明是从本机发出的请求，直接获取并返回本机IP地址</span>
            <span class="k">return</span> <span class="nf">getLocalRealIp</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ip</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 获取本机IP地址
     * @return 若配置了外网IP则优先返回外网IP；否则返回本地IP地址。如果本机没有被分配局域网IP地址（例如本机没有连接任何网络），则默认返回127.0.0.1
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getLocalRealIp</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">localIP</span> <span class="o">=</span> <span class="s">"127.0.0.1"</span><span class="o">;</span> <span class="c1">// 本地IP</span>
        <span class="nc">String</span> <span class="n">netIP</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 外网IP</span>

        <span class="nc">Enumeration</span><span class="o">&lt;</span><span class="nc">NetworkInterface</span><span class="o">&gt;</span> <span class="n">netInterfaces</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">netInterfaces</span> <span class="o">=</span> <span class="nc">NetworkInterface</span><span class="o">.</span><span class="na">getNetworkInterfaces</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SocketException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="c1">// 发生异常则返回null</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">InetAddress</span> <span class="n">ip</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">netIPFound</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 是否找到外网IP</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">netInterfaces</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">netIPFound</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Enumeration</span><span class="o">&lt;</span><span class="nc">InetAddress</span><span class="o">&gt;</span> <span class="n">address</span> <span class="o">=</span> <span class="n">netInterfaces</span><span class="o">.</span><span class="na">nextElement</span><span class="o">().</span><span class="na">getInetAddresses</span><span class="o">();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">address</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">ip</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">ip</span><span class="o">.</span><span class="na">isSiteLocalAddress</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ip</span><span class="o">.</span><span class="na">isLoopbackAddress</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="s">":"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="c1">// 外网IP</span>
                    <span class="n">netIP</span> <span class="o">=</span> <span class="n">ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">();</span>
                    <span class="n">netIPFound</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ip</span><span class="o">.</span><span class="na">isSiteLocalAddress</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ip</span><span class="o">.</span><span class="na">isLoopbackAddress</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="s">":"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="c1">// 内网IP</span>
                    <span class="n">localIP</span> <span class="o">=</span> <span class="n">ip</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">isNotBlank</span><span class="o">(</span><span class="n">netIP</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 如果配置了外网IP则优先返回外网IP地址</span>
            <span class="k">return</span> <span class="n">netIP</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">localIP</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * &lt;pre&gt;
     * isBlank(null)      = true
     * isBlank("")        = true
     * isBlank(" ")       = true
     * isBlank("bob")     = false
     * isBlank("  bob  ") = false
     * &lt;/pre&gt;
     * @param cs 输入参数
     * @return
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBlank</span><span class="o">(</span><span class="kd">final</span> <span class="nc">CharSequence</span> <span class="n">cs</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">strLen</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cs</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">strLen</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strLen</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="nc">Character</span><span class="o">.</span><span class="na">isWhitespace</span><span class="o">(</span><span class="n">cs</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * &lt;pre&gt;
     * isNotBlank(null)      = false
     * isNotBlank("")        = false
     * isNotBlank(" ")       = false
     * isNotBlank("bob")     = true
     * isNotBlank("  bob  ") = true
     * &lt;/pre&gt;
     * @param cs 输入参数
     * @return
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isNotBlank</span><span class="o">(</span><span class="kd">final</span> <span class="nc">CharSequence</span> <span class="n">cs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">isBlank</span><span class="o">(</span><span class="n">cs</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<hr />

</content>
      <pubDate>Fri, 13 Mar 2020 06:48:15 +0000</pubDate>
      <gui>/2020/03/13/IpUtils.html</gui>
    </item>
  
    <item>
      <title>Linux中让进程在后台运行更可靠的几种方法</title>
      <link>/2020/02/25/linux-nohup.html</link>
      <content><blockquote>
  <p>声明：本篇文章不是原创，转载自：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup">https://www.ibm.com/developerworks/cn/linux/l-cn-nohup</a> <br />
原文章已经写得很好了，这里转载过来，然后自己实践并记录一下。感谢原文章的作者。</p>
</blockquote>

<p>我们经常会碰到这样的问题，用telnet/ssh登录到远程的Linux服务器上，执行一些耗时的任务。但是在任务运行结束之前，本地机器和远程Linux机器的网络中断了，或者自己不小心关闭了终端，都会导致Linux上运行的任务被关闭。</p>

<p>如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。</p>

<h3 id="1-nohupsetsid-命令">1. <code class="language-plaintext highlighter-rouge">nohup/setsid/&amp;</code> 命令</h3>

<p><strong>场景描述：</strong><br />
如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？<br />
<strong>解决方案：</strong><br />
当用户注销(logout)或者网络断开时，终端会收到HUP(hangup)信号从而关闭其所有子进程。因此，思路有两个：</p>
<ul>
  <li>让进程忽略HUP信号；</li>
  <li>让进程运行在新的会话里从而成为不属于此终端的子进程。</li>
</ul>

<blockquote>
  <p><strong>hangup名称的来由：</strong> <br />
在Unix的早期版本中，每个终端都会通过modem和系统通讯。当用户logout时，modem就会挂断(hang up)电话。 同理，当modem断开连接时，就会给终端发送hangup信号来通知其关闭所有子进程。</p>
</blockquote>

<h4 id="11-nohup">1.1 <code class="language-plaintext highlighter-rouge">nohup</code></h4>

<p>nohup无疑是我们首先想到的办法。nohup的用途就是让提交的命令忽略hangup信号。先来看一下nohup的帮助信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>man <span class="nb">nohup
</span>NOHUP<span class="o">(</span>1<span class="o">)</span>                         User Commands                        NOHUP<span class="o">(</span>1<span class="o">)</span>

NAME
       <span class="nb">nohup</span> - run a <span class="nb">command </span>immune to hangups, with output to a non-tty

SYNOPSIS
       <span class="nb">nohup </span>COMMAND <span class="o">[</span>ARG]...
       <span class="nb">nohup </span>OPTION

DESCRIPTION
       Run COMMAND, ignoring hangup signals.

       <span class="nt">--help</span> display this <span class="nb">help </span>and <span class="nb">exit</span>

       <span class="nt">--version</span>
              output version information and <span class="nb">exit</span>
</code></pre></div></div>

<p>nohup的使用很简单，只要在执行的命令前加上nohup即可。标准输出和标准错误默认会被重定向到nohup.out文件中。一般我们可在结尾加上<code class="language-plaintext highlighter-rouge">&amp;</code>来将命令同时放入后台运行，也可用<code class="language-plaintext highlighter-rouge">&gt;filename 2&gt;&amp;1</code>来更改默认的重定向文件名。</p>

<p><strong>nohup + &amp; 的使用示例：</strong></p>

<p><em><code class="language-plaintext highlighter-rouge">ping www.ibm.com</code>是我们要运行的任务指令。</em></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nohup </span>ping www.ibm.com &amp;
<span class="o">[</span>1] 39907

<span class="nb">nohup</span>: 忽略输入并把输出追加到<span class="s2">"nohup.out"</span>
</code></pre></div></div>

<p>如果要修改标准输出和标准错误重定向的文件，可以使用<code class="language-plaintext highlighter-rouge">&gt;filename 2&gt;&amp;1</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nohup </span>ping www.ibm.com <span class="o">&gt;</span> output.log 2&gt;&amp;1 &amp;
</code></pre></div></div>

<p>上面我们把标准输出和标准错误输出重定向的文件改成了output.log，并在最后使用<code class="language-plaintext highlighter-rouge">&amp;</code>来将任务放到后台执行。</p>

<blockquote>
  <p>在Shell中，stdin是标准输入；stdout是标准输出；stderr是标准错误输出，分别用数字0，1，2表示。<br />
上面的2&gt;&amp;1就表示将stderr输出也重定向到stdout所重定向到的同名文件中，即&amp;1表示output.log文件。 <br />
所以当执行的命令发生标准错误，那么这个错误也会输出到你指定的输出文件中，即output.log文件中。</p>
</blockquote>

<h4 id="12-setsid">1.2 <code class="language-plaintext highlighter-rouge">setsid</code></h4>

<p>nohup能通过忽略HUP信号来使我们的进程避免中途被中断。但如果我们换个角度思考，如果我们的进程不属于接受HUP信号的终端的子进程，那么自然也就不会受到该终端的HUP信号的影响了。setsid就能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>man setsid
SETSID<span class="o">(</span>1<span class="o">)</span>                  Linux Programmer’s Manual                 SETSID<span class="o">(</span>1<span class="o">)</span>

NAME
       setsid - run a program <span class="k">in </span>a new session

SYNOPSIS
       setsid program <span class="o">[</span>arg...]

DESCRIPTION
       setsid runs a program <span class="k">in </span>a new session.
</code></pre></div></div>

<p>setsid的使用也同样很简单，只要在执行的命令前加上setsid即可。</p>

<p><strong>setsid使用示例：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>setsid ping www.ibm.com

<span class="nv">$ </span>ps <span class="nt">-ef</span> | <span class="nb">grep</span> <span class="s2">"UID</span><span class="se">\|</span><span class="s2">www.ibm.com"</span>
UID        PID    PPID   C  STIME TTY      TIME      CMD
LuzHo211   43482     1   0  16:13 ?        00:00:00  ping www.ibm.com
LuzHo211   43484  41875  0  16:13 pts/10   00:00:00  <span class="nb">grep </span>UID<span class="se">\|</span>www.ibm.com
</code></pre></div></div>

<p>可以看到我们任务的进程ID为43482，而它的父进程ID为1（即 init 进程ID），并不是当前终端的进程ID。说明使用setsid之后，任务进程变成了init进程的子进程，而不是当前终端进程的子进程。这样一来，就算我们当前终端被关闭或者当前终端的网络跟服务器发生中断，我们的任务进程也不会被关闭。</p>

<p>相比nohup中任务进程的父进程ID：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">nohup </span>ping www.ibm.com &amp;
<span class="o">[</span>1] 44109

<span class="nv">$ </span>ps <span class="nt">-ef</span> | <span class="nb">grep</span> <span class="s2">"UID</span><span class="se">\|</span><span class="s2">www.ibm.com</span><span class="se">\|</span><span class="s2">pts"</span>
UID        PID   PPID   C STIME TTY      TIME     CMD
LuzHo211   41875 41874  0 15:38 pts/10   00:00:00 <span class="nt">-bash</span>
LuzHo211   44109 41875  0 16:22 pts/10   00:00:00 ping www.ibm.com
LuzHo211   44157 41875  0 16:23 pts/10   00:00:00 ps <span class="nt">-ef</span>
LuzHo211   44158 41875  0 16:23 pts/10   00:00:00 <span class="nb">grep </span>UID<span class="se">\|</span>www.ibm.com<span class="se">\|</span>pts
</code></pre></div></div>

<p>可以看出我们的任务进程ID为44109，而其父进程ID为41875；41875就是我们当前终端的PID。</p>

<h4 id="13-">1.3 <code class="language-plaintext highlighter-rouge">&amp;</code></h4>

<p>这里还有一个关于subshell的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子shell中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。</p>

<p>当我们将”&amp;”也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中。也就是说，是无法通过jobs来查看的。让我们来看看为什么这样就能躲过HUP信号的影响吧。</p>

<p><strong>subshell示例：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="o">(</span>ping www.ibm.com &amp;<span class="o">)</span>

<span class="nv">$ </span>ps <span class="nt">-ef</span> | <span class="nb">grep</span> <span class="s2">"UID</span><span class="se">\|</span><span class="s2">www.ibm.com"</span>
UID        PID  PPID  C STIME TTY          TIME CMD
root     24535     1  0 10:23 pts/2    00:00:00 ping www.ibm.com
root     24650 24560  0 10:26 pts/3    00:00:00 <span class="nb">grep</span> <span class="nt">--color</span><span class="o">=</span>auto UID<span class="se">\|</span>www.ibm.com
</code></pre></div></div>

<p>从上例中可以看出，新提交的进程的父进程ID（PPID）为1（即init进程的PID），并不是当前终端的进程ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的HUP信号的影响了。</p>

<h3 id="2-disown-命令">2. <code class="language-plaintext highlighter-rouge">disown</code> 命令</h3>

<p><strong>场景描述：</strong><br />
在提交命令之前，在命令前加上nohup或者setsid就可以避免HUP信号的影响。但是若我们未加任何处理就已经提交了命令，该如何补救才能让它避免HUP信号的影响呢？ <br />
<strong>解决方案：</strong><br />
这时想加nohup或setsid已经为时已晚，只能通过作业调度和disown来解决这个问题。先看一下disown的帮助信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">disown</span> <span class="o">[</span><span class="nt">-ar</span><span class="o">]</span> <span class="o">[</span><span class="nt">-h</span><span class="o">]</span> <span class="o">[</span>jobspec ...]
    Without options, each jobspec is  removed  from  the  table  of
    active  jobs.   If  the <span class="nt">-h</span> option is given, each jobspec is not
    removed from the table, but is marked so  that  SIGHUP  is  not
    sent  to the job <span class="k">if </span>the shell receives a SIGHUP.  If no jobspec
    is present, and neither the <span class="nt">-a</span> nor the <span class="nt">-r</span> option  is  supplied,
    the  current  job  is  used.  If no jobspec is supplied, the <span class="nt">-a</span>
    option means to remove or mark all <span class="nb">jobs</span><span class="p">;</span> the <span class="nt">-r</span> option  without
    a  jobspec  argument  restricts operation to running jobs.  The
    <span class="k">return </span>value is 0 unless a jobspec does  not  specify  a  valid
    job.
</code></pre></div></div>

<p>可以看出，我们可以用如下方式来达成我们的目的：</p>

<ul>
  <li>用 disown -h <em>jobspec</em> 来使某个作业忽略HUP信号；</li>
  <li>用 disown -ah 来使所有的作业都忽略HUP信号；</li>
  <li>用 disown -rh 来使正在运行的作业忽略HUP信号。</li>
</ul>

<p>需要注意的是，当使用过disown之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用ps -ef查找到它。</p>

<p>但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了<strong>&amp;</strong>来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过jobs命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用ctrl + z（按住ctrl键的同时按住z键）了！</p>

<blockquote>
  <p><strong>灵活运用 ctrl + z</strong> <br />
我们可以用ctrl + z来将当前进程挂起到后台<strong>暂停运行</strong>，执行一些别的操作；然后再用 fg 来将挂起的进程重新放回前台（也可用 bg 来将挂起的进程放在后台）继续运行。这样我们就可以在一个终端内灵活切换运行多个任务。</p>
</blockquote>

<p>ctrl + z的用途就是将当前进程挂起（Suspend），然后我们就可以用jobs命令来查询它的作业号，再用bg <em>jobspec</em>来将它放入后台并继续运行。<strong>需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法</strong>。</p>

<p><strong>disown 示例1：</strong>提交命令时已经用<strong>&amp;</strong>将命令放入后台运行，则可以直接使用disown</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ping www.ibm.com <span class="o">&gt;</span> ping.log &amp;
<span class="o">[</span>1] 25259

<span class="nv">$ </span><span class="nb">jobs</span>
<span class="o">[</span>1]+  Running                 ping www.ibm.com <span class="o">&gt;</span> ping.log &amp;

<span class="nv">$ </span><span class="nb">disown</span> <span class="nt">-h</span> %1

<span class="nv">$ </span>ps <span class="nt">-ef</span> | <span class="nb">grep </span>ping
root     25259 25167  0 11:02 pts/4    00:00:00 ping www.ibm.com
root     25261 25167  0 11:03 pts/4    00:00:00 <span class="nb">grep</span> <span class="nt">--color</span><span class="o">=</span>auto ping
</code></pre></div></div>

<blockquote>
  <p>我在Ubuntu上试过，当提交命令的时候就使用&amp;将命令放入后台运行，如果当前终端关闭了，我们提交的命令并不会被终止，并且命令会自动被挂到init进程下面，保持继续运行。</p>
</blockquote>

<p><strong>disown 示例2：</strong>提交命令时未使用<strong>&amp;</strong>将命令放入后台运行，可使用ctrl+z 和 bg 将其放入后台，再使用disown</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 提交命令（不带&amp;）并ctrl + z将命令挂起
<span class="nv">$ </span>ping www.ibm.com <span class="o">&gt;</span> ping.log
^Z
<span class="o">[</span>1]+  Stopped                 ping www.ibm.com <span class="o">&gt;</span> ping.log

// jobs查看作业列表，看到命令已经被挂起
<span class="nv">$ </span><span class="nb">jobs</span>
<span class="o">[</span>1]+  Stopped                 ping www.ibm.com <span class="o">&gt;</span> ping.log

// 使用bg将挂起的任务放到后台运行
<span class="nv">$ </span><span class="nb">bg</span> %1
<span class="o">[</span>1]+ ping www.ibm.com <span class="o">&gt;</span> ping.log &amp;

// 使用jobs查看，发现任务已经在后台运行
<span class="nv">$ </span><span class="nb">jobs</span>
<span class="o">[</span>1]+  Running                 ping www.ibm.com <span class="o">&gt;</span> ping.log &amp;

// 使用disown <span class="nt">-h</span> 来让任务免受HUP信号的干扰
<span class="nv">$ </span><span class="nb">disown</span> <span class="nt">-h</span> %1

<span class="nv">$ </span>ps <span class="nt">-ef</span> | <span class="nb">grep </span>ping
root     25382 25296  0 11:13 pts/6    00:00:00 ping www.ibm.com
root     25387 25296  0 11:16 pts/6    00:00:00 <span class="nb">grep</span> <span class="nt">--color</span><span class="o">=</span>auto ping
</code></pre></div></div>

<h3 id="3-screen命令">3. <code class="language-plaintext highlighter-rouge">screen</code>命令</h3>

<p><strong>场景描述：</strong><br />
我们已经知道了如何让进程免受HUP信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？ <br />
<strong>解决方案：</strong><br />
此时最方便的方法就是screen了。简单的说，screen提供了ANSI/VT100的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用screen能够避免HUP信号的影响。先看一下screen的帮助信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SCREEN<span class="o">(</span>1<span class="o">)</span>                                                           SCREEN<span class="o">(</span>1<span class="o">)</span>
 
NAME
       screen - screen manager with VT100/ANSI terminal emulation
 
SYNOPSIS
       screen <span class="o">[</span> <span class="nt">-options</span> <span class="o">]</span> <span class="o">[</span> cmd <span class="o">[</span> args <span class="o">]</span> <span class="o">]</span>
       screen <span class="nt">-r</span> <span class="o">[[</span>pid.]tty[.host]]
       screen <span class="nt">-r</span> sessionowner/[[pid.]tty[.host]]
 
DESCRIPTION
       Screen  is  a  full-screen  window manager that multiplexes a physical
       terminal between several  processes  <span class="o">(</span>typically  interactive  shells<span class="o">)</span><span class="nb">.</span>
       Each  virtual  terminal provides the functions of a DEC VT100 terminal
       and, <span class="k">in </span>addition, several control functions from the  ISO  6429  <span class="o">(</span>ECMA
       48,  ANSI  X3.64<span class="o">)</span>  and ISO 2022 standards <span class="o">(</span>e.g. insert/delete line and
       support <span class="k">for </span>multiple character sets<span class="o">)</span><span class="nb">.</span>  There is a  scrollback  <span class="nb">history
       </span>buffer  <span class="k">for  </span>each virtual terminal and a copy-and-paste mechanism that
       allows moving text regions between windows.
</code></pre></div></div>

<p>screen的使用也很方便，有以下几个常用选项：</p>

<ul>
  <li>用 screen -dmS <em>session name</em> 来建立一个处于断开模式下的会话（并指定其会话名）;</li>
  <li>用 screen -list 来列出所有会话；</li>
  <li>用 screen -r <em>session name</em> 来重新连接指定会话；</li>
  <li>用快捷键 ctrl+a d 来暂时断开当前会话。</li>
</ul>

<p><strong>screen 示例：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>screen <span class="nt">-dmS</span> Urumchi

<span class="nv">$ </span>screen <span class="nt">-list</span>
There is a screen on:
	26332.Urumchi	<span class="o">(</span>02/26/2020 12:08:50 PM<span class="o">)</span>	<span class="o">(</span>Detached<span class="o">)</span>
1 Socket <span class="k">in</span> /var/run/screen/S-root.

<span class="nv">$ </span>screen <span class="nt">-r</span> Urumchi
</code></pre></div></div>

<p>当我们用<code class="language-plaintext highlighter-rouge">-r</code>参数连接到screen会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心HUP信号会对我们的进程造成影响，也不用给每个命令前都加上nohup或者setsid了。这是为什么呢？让我来看一下下面两个例子吧。</p>

<p><strong>1. 未使用 screen 时新进程的进程树：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ping www.baidu.com <span class="o">&gt;</span> ping.log &amp;
<span class="o">[</span>1] 26366

<span class="nv">$ </span>pstree <span class="nt">-H</span> 26366
systemd─┬─AliYunDun───23<span class="k">*</span><span class="o">[{</span>AliYunDun<span class="o">}]</span>
        ├─AliYunDunUpdate───3<span class="k">*</span><span class="o">[{</span>AliYunDunUpdate<span class="o">}]</span>    
        └─sshd─┬─7<span class="k">*</span><span class="o">[</span>sshd───bash]
               └─sshd───bash─┬─ping
                             └─pstree

</code></pre></div></div>

<p>可以看出，未使用screen时我们所处的bash是sshd的子进程，当ssh断开连接时，HUP信号自然会影响到它下面的所有子进程（包括我们新建立的ping进程）。</p>

<p><strong>2. 使用了 screen 后新进程的进程树：</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>screen <span class="nt">-dmS</span> my_new_session

<span class="nv">$ </span>screen <span class="nt">-r</span> my_new_session

<span class="nv">$ </span>ping www.baidu.com <span class="o">&gt;</span> ping.log &amp;
<span class="o">[</span>1] 26421

<span class="nv">$ </span>pstree <span class="nt">-H</span> 26421
systemd─┬─AliYunDun───23<span class="k">*</span><span class="o">[{</span>AliYunDun<span class="o">}]</span>
        ├─AliYunDunUpdate───3<span class="k">*</span><span class="o">[{</span>AliYunDunUpdate<span class="o">}]</span>
        ├─screen───bash─┬─ping
        │               └─pstree
        └─sshd─┬─8<span class="k">*</span><span class="o">[</span>sshd───bash]
               └─sshd───bash───screen
</code></pre></div></div>

<p>可以看到，使用了screen之后，我们所处的bash则变成了screen进程的子进程，而screen又是systemd的子进程。那么当ssh断开连接时，HUP信号自然不会影响到screen下面的子进程了。</p>

<h3 id="4-总结">4. 总结</h3>

<p>现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。nohup/setsid无疑是临时需要时最方便的方法，disown能帮助我们来事后补救当前已经在运行了的作业，而screen则是在大批量操作时不二的选择了。</p>

<hr />

</content>
      <pubDate>Tue, 25 Feb 2020 01:00:00 +0000</pubDate>
      <gui>/2020/02/25/linux-nohup.html</gui>
    </item>
  
    <item>
      <title>Mac OS下iTerm2终端使用rz/sz进行远程文件的下载/上传</title>
      <link>/2020/01/13/iterm2-lrzsz.html</link>
      <content><p><img src="/static/image/2020-01/iterm2-logo2x.jpg" alt="iterm2-logo2x.jpg" /></p>

<p>Mac OS下使用iTerm2终端时，经常会使用SSH方式登录到远程服务器，进行文件上传/下载操作。一般情况使用scp命令或者XFtp应用来直接上传/下载文件，但是如果远程服务器跟我们本地电脑之间隔了一层跳板机，scp和XFtp就不太好用了。作为替代方案，我们可以使用sz/rz命令来上传/下载文件。</p>

<h3 id="1-安装lrzsz程序包">1. 安装lrzsz程序包</h3>

<p>sz和rz命令是lrzsz程序包提供的两个命令，所以先安装lrzsz程序包。这里通过<a href="https://brew.sh">Homebrew</a>来安装lrzsz程序包，如果没有安装Homebrew，请先自行安装。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>brew <span class="nb">install </span>lrzsz
</code></pre></div></div>

<h3 id="2-iterm2的相关配置脚本">2. iTerm2的相关配置脚本</h3>

<p>先下载这两个脚本文件：<a href="/static/files/iterm2-send-zmodem.sh">iterm2-send-zmodem.sh</a> 和 <a href="/static/files/iterm2-recv-zmodem.sh">iterm2-recv-zmodem.sh</a></p>

<p>将<code class="language-plaintext highlighter-rouge">iterm2-send-zmodem.sh</code>和<code class="language-plaintext highlighter-rouge">iterm2-recv-zmodem.sh</code>脚本放到<code class="language-plaintext highlighter-rouge">/usr/local/bin</code>目录下，并赋予可执行的权限：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">chmod</span> +x /usr/local/bin/iterm2-send-zmodem.sh /usr/local/bin/iterm2-recv-zmodem.sh
</code></pre></div></div>

<h3 id="3-配置iterm2">3. 配置iTerm2</h3>

<p><em>找到iTerm2的配置项：iTerm2的Preferences -&gt; Profiles -&gt; Default -&gt; Advanced -&gt; Triggers</em></p>

<p>点击Triggers的Edit按钮，按照以下表格进行配置：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Regular Expression</th>
      <th style="text-align: left">Action</th>
      <th style="text-align: left">Parameters</th>
      <th style="text-align: left">Instant</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">rz waiting to receive.\*\*B0100</code></td>
      <td style="text-align: left">Run Silent Coprocess</td>
      <td style="text-align: left">/usr/local/bin/iterm2-send-zmodem.sh</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">checked</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">\*\*B00000000000000</code></td>
      <td style="text-align: left">Run Silent Coprocess</td>
      <td style="text-align: left">/usr/local/bin/iterm2-recv-zmodem.sh</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">checked</code></td>
    </tr>
  </tbody>
</table>

<p><strong>注意：最后一项Instant一定要勾选上！</strong> 如下图的配置：</p>

<p><img src="/static/image/2020-01/iterm2-config.png" alt="iterm2-config.png" /></p>

<hr />

<p>参考：</p>
<ul>
  <li><a href="https://molunerfinn.com/iTerm2-lrzsz/#%E9%85%8D%E7%BD%AEiTerm2" target="_blank">https://molunerfinn.com/iTerm2-lrzsz/#%E9%85%8D%E7%BD%AEiTerm2</a></li>
</ul>
</content>
      <pubDate>Mon, 13 Jan 2020 07:25:13 +0000</pubDate>
      <gui>/2020/01/13/iterm2-lrzsz.html</gui>
    </item>
  
    <item>
      <title>图片在线处理工具</title>
      <link>/2020/01/10/pict-tools.html</link>
      <content><h3 id="1-图片压缩工具">1. 图片压缩工具</h3>

<p>写文章的时候免不了要放图片，但是图片太大会影响网页加载速度。记录几款不错的在线图片压缩工具：</p>

<ul>
  <li><a href="https://www.picdiet.com/zh-cn" target="_blank">picdiet</a></li>
  <li><a href="https://tinypng.com" target="_blank">tinypng</a></li>
  <li><a href="https://tiomg.org/image" target="_blank">tiomg</a></li>
</ul>

<h3 id="2-图片格式转换工具">2. 图片格式转换工具</h3>

<ul>
  <li>支持多种图片格式转换，例如<code class="language-plaintext highlighter-rouge">png</code>和<code class="language-plaintext highlighter-rouge">jpg</code>互转：<a href="https://png2jpg.com/zh/" target="_blank">png2jpg</a></li>
</ul>

<hr />

</content>
      <pubDate>Fri, 10 Jan 2020 07:05:57 +0000</pubDate>
      <gui>/2020/01/10/pict-tools.html</gui>
    </item>
  
    <item>
      <title>OAuth 2.0</title>
      <link>/2019/12/15/oauth.html</link>
      <content><p><a href="http://www.ruanyifeng.com/home.html" target="_blank">阮一峰</a> 大佬的系列文章已经讲的很清楚了，有理论有实操(包教包会)，强力推荐。不多废话，直接上链接：</p>

<ul>
  <li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank">理解OAuth 2.0</a></li>
  <li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank">OAuth 2.0 的一个简单解释</a></li>
  <li><a href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank">OAuth 2.0 的四种方式</a></li>
  <li><a href="https://www.ruanyifeng.com/blog/2019/04/github-oauth.html" target="_blank">GitHub OAuth 第三方登录示例教程</a></li>
</ul>

<hr />

</content>
      <pubDate>Sun, 15 Dec 2019 04:03:23 +0000</pubDate>
      <gui>/2019/12/15/oauth.html</gui>
    </item>
  
    <item>
      <title>CAS单点登录技术</title>
      <link>/2019/12/15/sso-cas.html</link>
      <content><h3 id="1-sso-和cas">1. <code class="language-plaintext highlighter-rouge">SSO</code> 和<code class="language-plaintext highlighter-rouge">CAS</code></h3>

<p>在企业应用开发中，经常会使用到单点登录技术（Single Sign-on）来处理企业的各个应用之间的共享登录场景。</p>

<p>通常，企业内部会有多个应用，每个应用都需要用户登录之后才能允许用户访问其内容。现实中，一般不会为每个应用都实现一套登录逻辑，因为这样做既费时、费力又难以维护。而是通过一个统一登录服务，让每个应用都接入这个统一登录服务，这个登录服务可以在各个应用之间共享登录态。即，当用户在其中一个应用登录成功之后，在继续访问企业中的其他任何应用的时候都不需要重新登录，从而达到提升用户体验的效果。</p>

<blockquote>
  <p>试想，如果某个企业拥有10个应用服务并且用户每天都会使用这10个服务，用户每访问一个应用都需要重新填写账号密码进行登录，用户体验是不是很差？</p>
</blockquote>

<p>单点登录技术（SSO）就是为了解决这种场景而生的。用户在一次成功登录之后，只要本次登录未过期，用户就可以直接访问接入了同一个单点登录服务的其他应用，而不需要再登录一次。即，<strong>一处登录，处处访问</strong>。</p>

<p>SSO是一种架构设计，CAS则是SSO的一种实现。CAS（Central Authentication Service）单点登录技术是 <a href="https://www.apereo.org">Apereo</a> 的一个开源项目，该项目包含了CAS单点登录协议、CAS客户端以及CAS服务器等项目（<a href="https://www.apereo.org/projects/cas">CAS官网地址</a>）。</p>

<h3 id="2-cas架构">2. <code class="language-plaintext highlighter-rouge">CAS</code>架构</h3>

<p><img src="/static/image/2019/cas_architecture.png" alt="cas_architecture" /></p>

<p>CAS Clients是各种接入了CAS单点登录服务的业务应用；CAS Server就是单点登录服务器。各个应用可以通过各种协议接入CAS服务器，例如CAS、SALML以及OAuth协议等（本文只介绍 <a href="https://apereo.github.io/cas/6.1.x/protocol/CAS-Protocol.html">CAS Protocol</a>）；CAS服务器支持多种用户认证信息数据源，例如LDAP、Database以及Active Directory等，我们可以根据实际场景来选择不同的数据源。</p>

<h3 id="3-cas协议cas-protocol">3. <code class="language-plaintext highlighter-rouge">CAS</code>协议（CAS Protocol）</h3>

<p>CAS协议（<a href="https://apereo.github.io/cas/6.1.x/protocol/CAS-Protocol-Specification.html">CAS-Protocol-Specification</a>）当前有三个版本：CAS 1.0、2.0以及3.0</p>

<ul>
  <li>CAS 1.0 —— 基础模式，仅提供WEB应用之间的单点登录；</li>
  <li>CAS 2.0 —— 代理模式，可以用于WEB应用或者非WEB应用之间的单点登录，例如移动应用+WEB应用等；</li>
  <li>CAS 3.0 —— 在兼容1.0和2.0的基础上，新增了其他更高级的特性。</li>
</ul>

<p>这里只介绍CAS 1.0版本的协议原理。CAS 1.0协议的工作流程图如下图所示：</p>

<p><img src="/static/image/2019/cas_web_flow_diagram.png" alt="cas_web_flow_diagram" /></p>

<p>这里先介绍几个CAS登录流程中涉及的相关票据（Ticket）的概念：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TGT</code> —— Ticket Granting Ticket，用户登录成功后，CAS服务器为用户签发的一个登录票据。TGT就是服务器存储的用户Session的ID。如果CAS服务器通过TGT可以查询出用户的Session信息，则说明该用户已经登录过了。</li>
  <li><code class="language-plaintext highlighter-rouge">TGC</code> —— Ticket Granting Cookie，TGT是存储在CAS服务器端的Session的ID，TGC则是存储在浏览器端的Cookie的Key。用户登录成功之后，每次访问CAS服务器时浏览器都会自动携带Cookie中的TGC（<em>Cookie: TGC=TGT-12345678</em>），这样CAS服务器就能拿到TGT从而获取到用户的会话信息。</li>
  <li><code class="language-plaintext highlighter-rouge">ST</code> —— Service Ticket，用户登录成功后，CAS服务器为该用户签发的访问某一个应用的票据。用户访问应用时，会在URL上携带这个ST票据，这个应用收到请求后会去找CAS服务器验证ST的有效性，ST有效则CAS服务器会向该应用返回该用户的会话信息。如果ST验证有效，则该应用相信该用户已经登录，允许其访问应用资源。</li>
</ul>

<h3 id="4-理解cas工作流程">4. 理解CAS工作流程</h3>

<p>我将上面的CAS工作流程翻译了一遍，做成比较直观的流程图以方便理解：</p>

<p><img src="/static/image/2019/cas_work_flow.png" alt="cas_work_flow.png" /></p>

<p>流程图有了，现在我们根据流程图一步步走一遍，加深理解。</p>

<blockquote>
  <p>现在，用户首次访问应用A：<em>http://web.a.com</em></p>
</blockquote>

<p><strong>步骤1：</strong>用户通过浏览器访问应用A：<em>http://web.a.com</em> 。应用A收到请求，先检查Cookie（这里的Cookie是应用A的局部Cookie，而非CAS服务器的全局TGC）中有没有携带该用户的会话ID（局部会话JSSESION）。如果没有则说明用户未登录，应用A会302重定向到CAS服务器并在重定向的URL上携带自己的应用链接：<em>http://cas.local.com/login?service=http%3a%2f%2fweb.a.com</em> 。</p>

<p><strong>步骤2：</strong>CAS服务器收到应用A的302跳转请求，先检查Cookie中是否包含TGC。如果没有TGC则说明用户未登录过，CAS服务器会向浏览器返回登录表单页面，让用户填写账号密码信息进行登录。</p>

<p><strong>步骤3：</strong>用户填写登录账号密码，点击登录。CAS服务器会验证用户的账号密码正确性，如果正确，执行如下动作：</p>

<ul>
  <li>生成用户的会话信息，存储在服务器缓存（例如<code class="language-plaintext highlighter-rouge">Redis</code>）中，TGT就是缓存会话ID（Key）；</li>
  <li>通过Response向浏览器的<code class="language-plaintext highlighter-rouge">cas.local.com</code>域写入 <code class="language-plaintext highlighter-rouge">Set-Cookie: CASTGC=TGT-12345678</code> ；</li>
  <li>为用户签发一个用于访问应用A的<code class="language-plaintext highlighter-rouge">ST</code>票据。</li>
</ul>

<p>最后，CAS会302跳转回应用A并将<code class="language-plaintext highlighter-rouge">ST</code>传递给应用A：<em>http://web.a.com?ticket=ST-345678</em> 。</p>

<p>应用A拿到<code class="language-plaintext highlighter-rouge">ST</code>票据之后，会向CAS服务器请求验证<code class="language-plaintext highlighter-rouge">ST</code>的有效性。若<code class="language-plaintext highlighter-rouge">ST</code>有效，应用A会创建该用户的局部会话，并将用户的局部会话Key写入浏览器Cookie（写入自己的域名<code class="language-plaintext highlighter-rouge">web.a.com</code>）：<code class="language-plaintext highlighter-rouge">Set-Cookie: JSSESION=ABC1234567</code> 。这样在JSESSION过期之前，用户再访问应用A的时候，就不需要再跳转到CAS服务器确认了。</p>

<blockquote>
  <p>接下来，用户首次访问应用B：<em>http://web.b.com</em> 。</p>
</blockquote>

<p><strong>步骤1：</strong>应用B同样也会先检查Cookie（这里的Cookie是应用B的局部Cookie，而非CAS服务器的全局TGC）中有没有携带该用户的会话ID。因为用户还没在应用B创建过局部会话，所以应用B会同样跳转到CAS服务器：<em>http://cas.local.com/login?service=http%3a%2f%2fweb.b.com</em> 。</p>

<p><strong>步骤2：</strong>由于用户在访问应用A的时候，CAS已经向浏览器写入了全局Cookie：<code class="language-plaintext highlighter-rouge">CASTGC=TGT-12345678</code>，所以应用B通过<em>http://cas.local.com/login?service=http%3a%2f%2fweb.b.com</em>跳转到CAS服务器时，浏览器会自动给cas.local.com域名携带上<code class="language-plaintext highlighter-rouge">CASTGC=TGT-12345678</code>这个Cookie给CAS服务器。CAS服务器发现请求中带有<code class="language-plaintext highlighter-rouge">CASTGC=TGT-12345678</code>这个Cookie，则会验证<code class="language-plaintext highlighter-rouge">TGT-12345678</code>是否有效（即是否能查到用户的Session），若CAS服务器验证TGT有效，则认为用户登录过了，不会再向用户返回登录表单页面，而是直接为用户生成一个用于访问应用B的ST票据。</p>

<p><strong>步骤3：</strong>应用B接下来就跟应用A所做的事情一样了：验证<code class="language-plaintext highlighter-rouge">ST</code>的有效性，创建该用户的局部会话，并将用户的局部会话Key写入浏览器Cookie（写入自己的域名<code class="language-plaintext highlighter-rouge">web.b.com</code>）：<code class="language-plaintext highlighter-rouge">Set-Cookie: JSSESION=XYZ1234567</code> 。同样在JSESSION过期之前，用户再访问应用B的时候，就不需要再跳转到CAS服务器进行确认了。</p>

<blockquote>
  <p>我们发现，用户在应用A完成登录之后，再继续访问应用B的时候完全就不需要再次登录。这是因为CAS服务器的全局TGC的存在，让用户轻松地完成了跨域（<code class="language-plaintext highlighter-rouge">web.a.com</code>和<code class="language-plaintext highlighter-rouge">web.b.com</code>两个域）的单点登录，一处登录，处处访问！</p>
</blockquote>

<h3 id="5-st票据的安全性">5. ST票据的安全性</h3>

<p>目标应用在是否创建用户局部会话的判定关键在于ST票据的有效性。所以才会先去找CAS服务器验证这个ST是不是服务器颁发的、有效的。</p>

<p>ST票据是用户登录成功后，CAS服务器重定向到目标应用时携带在URL上的参数。这样很容易被攻击者拦截到这个参数。如果攻击者抢在用户之前先向CAS服务器验证了这个票据，那么用户将会验证失败，无法登录目标应用。</p>

<p>这时候可能CAS需要做一些安全的防范，比如在生成ST票据的时候使用多种参数组合，例如：随机数 + IP等来判断前来验证ST票据的主体是不是用户将要登录的目标应用，若不是则拒绝验证请求。</p>

<p>ST在验证成功之后，CAS服务器会向目标应用返回用户的信息，目标应用根据这些用户信息创建用户的局部会话。出于安全考虑，CAS服务器应该在验证完毕ST之后，删除ST在CAS服务器上的缓存，保证每次请求都生成新的ST票据。</p>

<hr />

</content>
      <pubDate>Sun, 15 Dec 2019 04:03:23 +0000</pubDate>
      <gui>/2019/12/15/sso-cas.html</gui>
    </item>
  
    <item>
      <title>Dubbo SPI</title>
      <link>/2019/12/14/dubbo-spi.html</link>
      <content><p>之前写过一篇Java SPI机制：<a href="/2019/10/12/java-spi.html" target="_blank">Java SPI</a>。<a href="https://dubbo.apache.org/zh/" target="_blank">Dubbo</a> 其实也有自己的一套SPI机制，但跟Java SPI有所区别。这篇文章是在学习了Dubbo SPI的原理之后写的，很多东西直接借鉴原文，但是目的为了巩固所学，加深理解。</p>

<h3 id="一dubbo-spi的使用">一、Dubbo SPI的使用</h3>

<p>与Java SPI相似，Dubbo也是通过特定的目录去加载SPI扩展类，只不过两者加载扩展类的目录不同：Java的SPI机制从<code class="language-plaintext highlighter-rouge">META-INF/services</code>目录加载，Dubbo SPI从<code class="language-plaintext highlighter-rouge">META-INF/dubbo</code>目录加载。</p>

<p>使用Dubbo SPI时，对外发布的SPI接口必须都加上<code class="language-plaintext highlighter-rouge">@SPI</code>的注解：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.loji44.spi</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.dubbo.common.extension.SPI</span><span class="o">;</span>

<span class="nd">@SPI</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PrinterV2</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>实现方提供好实现之后，在自己源代码的<code class="language-plaintext highlighter-rouge">META-INF/dubbo</code>目录下面新增一个文件，文件名就是SPI接口的全限定名：</p>

<p><img src="/static/image/2020/dubbo-spi.png" alt="dubbo-spi.png" /></p>

<p>接下来看看怎么加载并使用扩展类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrinterLauncher</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Dubbo SPI机制使用</span>
        <span class="nc">ExtensionLoader</span><span class="o">&lt;</span><span class="nc">PrinterV2</span><span class="o">&gt;</span> <span class="n">extensionLoader</span> <span class="o">=</span> <span class="nc">ExtensionLoader</span><span class="o">.</span><span class="na">getExtensionLoader</span><span class="o">(</span><span class="nc">PrinterV2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        
        <span class="c1">// 加载 epson-v1 扩展类</span>
        <span class="nc">PrinterV2</span> <span class="n">printerV2</span> <span class="o">=</span> <span class="n">extensionLoader</span><span class="o">.</span><span class="na">getExtension</span><span class="o">(</span><span class="s">"epson-v1"</span><span class="o">);</span>
        <span class="n">printerV2</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"我要打印很多钱"</span><span class="o">);</span>
        
        <span class="c1">// 加载 epson-v2 扩展类</span>
        <span class="n">printerV2</span> <span class="o">=</span> <span class="n">extensionLoader</span><span class="o">.</span><span class="na">getExtension</span><span class="o">(</span><span class="s">"epson-v2"</span><span class="o">);</span>
        <span class="n">printerV2</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"我要打印很多钱"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="c1">// 运行结果</span>
<span class="n">爱普生第一代打印机为您服务</span><span class="err">：</span><span class="n">我要打印很多钱</span>
<span class="n">爱普生第二代打印机以</span><span class="err">「</span><span class="mi">10</span><span class="n">倍</span><span class="err">」</span><span class="n">速度为您服务</span><span class="err">：</span><span class="n">我要打印很多钱</span>
</code></pre></div></div>

<h3 id="二dubbo-spi源码">二、Dubbo SPI源码</h3>

<blockquote>
  <p>源码基于 Apache Dubbo 2.7.5 版本。</p>
</blockquote>

<p>Dubbo SPI封装在<code class="language-plaintext highlighter-rouge">org.apache.dubbo.common.extension.ExtensionLoader</code>类中。</p>

<p>第一步：先看看<code class="language-plaintext highlighter-rouge">getExtensionLoader</code>方法：基于SPI接口Class类型获取ExtensionLoader的实例</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">ExtensionLoader</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">getExtensionLoader</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Extension type == null"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">type</span><span class="o">.</span><span class="na">isInterface</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Extension type ("</span> <span class="o">+</span> <span class="n">type</span> <span class="o">+</span> <span class="s">") is not an interface!"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">withExtensionAnnotation</span><span class="o">(</span><span class="n">type</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// SPI接口必须加上Dubbo提供的@SPI注解</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Extension type ("</span> <span class="o">+</span> <span class="n">type</span> <span class="o">+</span>
                    <span class="s">") is not an extension, because it is NOT annotated with @"</span> <span class="o">+</span> <span class="no">SPI</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">ExtensionLoader</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">loader</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ExtensionLoader</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="no">EXTENSION_LOADERS</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">type</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">loader</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 这里直接针对某个SPI接口的Class类型做一个本地缓存，下次再来就从缓存取</span>
            <span class="no">EXTENSION_LOADERS</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ExtensionLoader</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;(</span><span class="n">type</span><span class="o">));</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ExtensionLoader</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="no">EXTENSION_LOADERS</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">type</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">loader</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>第二步：接下来看看getExtension方法如何创建扩展类的实例</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 第一节使用的时候说过，Dubbo SPI通过键值对来定义扩展类的加载，这里传入具体的扩展类的key来获取扩展类对象</span>
<span class="c1">// 这个键值对的设计可以实现按需加载，根据key来加载并初始化某个扩展对象，不像Java SPI一次性加载并初始化所有扩展类。</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">getExtension</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Extension name == null"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="s">"true"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">name</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getDefaultExtension</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 通过标准的双重检验单例模式来保证key对应扩展类对象的单例</span>
    <span class="c1">// 这里是查询本地缓存，缓存命中就直接返回扩展类对象实例</span>
    <span class="kd">final</span> <span class="nc">Holder</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">holder</span> <span class="o">=</span> <span class="n">getOrCreateHolder</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="nc">Object</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">holder</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 重点在createExtension方法：如果缓存没命中，则走这里加载并创建key对应的扩展类对象</span>
                <span class="n">instance</span> <span class="o">=</span> <span class="n">createExtension</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
                <span class="n">holder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">instance</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>第三步：继续跟踪createExtension方法：加载并创建key对应的扩展类对象，最终通过反射创建扩展类的实例</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="no">T</span> <span class="nf">createExtension</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// getExtensionClasses方法的作用是扫描特定的目录来加载Dubbo SPI定义的键值对映射关系，即key和value，并放到本地缓存中。</span>
    <span class="c1">// value就是实现方提供的具体实现类的全限定名。</span>
    <span class="cm">/* 扫描的目录如下列表：
         META-INF/services/
         META-INF/dubbo/
         META-INF/dubbo/internal/
         
       可以看出Dubbo对Java SPI目录做了兼容。
       
       getExtensionClasses()方法里面还包含了类加载的过程，基本与Java SPI类似，这里不赘述
     */</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">getExtensionClasses</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">clazz</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="nf">findException</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 根据getExtensionClasses().get(name)获取到了key对应的扩展类的Class对象，先查询缓存</span>
        <span class="no">T</span> <span class="n">instance</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="no">EXTENSION_INSTANCES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">clazz</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 缓存未命中，则通过反射创建扩展类的示例并添加到本地缓存，下次再来就直接走缓存</span>
            <span class="no">EXTENSION_INSTANCES</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">());</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="no">EXTENSION_INSTANCES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">clazz</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// Dubbo SPI还提供了IoC特性来注入扩展类所依赖的其他对象，不过Dubbo SPI只支持setter方法注入方式</span>
        <span class="c1">// 后面章节将单独对Dubbo SPI的IoC做分析，这里先略过</span>
        <span class="n">injectExtension</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Class</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">wrapperClasses</span> <span class="o">=</span> <span class="n">cachedWrapperClasses</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">CollectionUtils</span><span class="o">.</span><span class="na">isNotEmpty</span><span class="o">(</span><span class="n">wrapperClasses</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">wrapperClass</span> <span class="o">:</span> <span class="n">wrapperClasses</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">instance</span> <span class="o">=</span> <span class="n">injectExtension</span><span class="o">((</span><span class="no">T</span><span class="o">)</span> <span class="n">wrapperClass</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="n">type</span><span class="o">).</span><span class="na">newInstance</span><span class="o">(</span><span class="n">instance</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">initExtension</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Extension instance (name: "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">", class: "</span> <span class="o">+</span>
                <span class="n">type</span> <span class="o">+</span> <span class="s">") couldn't be instantiated: "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>第四步：getExtensionClasses方法的作用是扫描特定的目录来加载Dubbo SPI定义的键值对映射关系，即key和value，并放到本地缓存中：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">final</span> <span class="nc">Holder</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;&gt;&gt;</span> <span class="n">cachedClasses</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Holder</span><span class="o">&lt;&gt;();</span>

<span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">getExtensionClasses</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 先从缓存中获取当前已加载的扩展类的Class对象</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">classes</span> <span class="o">=</span> <span class="n">cachedClasses</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">classes</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 缓存未命中则使用双重检验单例模式：加锁</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">cachedClasses</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">classes</span> <span class="o">=</span> <span class="n">cachedClasses</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">classes</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 加载所有的扩展类的Class对象：只是加载扩展类，并未创建实例</span>
                <span class="n">classes</span> <span class="o">=</span> <span class="n">loadExtensionClasses</span><span class="o">();</span>
                <span class="c1">// cachedClasses缓存了所有的扩展类的Class对象：这些Class对象可以用来创建对应的扩展类的实例</span>
                <span class="n">cachedClasses</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">classes</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">classes</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>第五步：loadExtensionClasses方法加载所有扩展类</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICES_DIRECTORY</span> <span class="o">=</span> <span class="s">"META-INF/services/"</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">DUBBO_DIRECTORY</span> <span class="o">=</span> <span class="s">"META-INF/dubbo/"</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">DUBBO_INTERNAL_DIRECTORY</span> <span class="o">=</span> <span class="no">DUBBO_DIRECTORY</span> <span class="o">+</span> <span class="s">"internal/"</span><span class="o">;</span>

<span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">loadExtensionClasses</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">cacheDefaultExtensionName</span><span class="o">();</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">extensionClasses</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    
    <span class="c1">// loadDirectory方法就是实际读取指定目录下的SPI接口全限定名为文件名的文件，并解析</span>
    <span class="n">loadDirectory</span><span class="o">(</span><span class="n">extensionClasses</span><span class="o">,</span> <span class="no">DUBBO_INTERNAL_DIRECTORY</span><span class="o">,</span> <span class="n">type</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="kc">true</span><span class="o">);</span>
    <span class="n">loadDirectory</span><span class="o">(</span><span class="n">extensionClasses</span><span class="o">,</span> <span class="no">DUBBO_INTERNAL_DIRECTORY</span><span class="o">,</span> <span class="n">type</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">replace</span><span class="o">(</span><span class="s">"org.apache"</span><span class="o">,</span> <span class="s">"com.alibaba"</span><span class="o">),</span> <span class="kc">true</span><span class="o">);</span>
    <span class="n">loadDirectory</span><span class="o">(</span><span class="n">extensionClasses</span><span class="o">,</span> <span class="no">DUBBO_DIRECTORY</span><span class="o">,</span> <span class="n">type</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="n">loadDirectory</span><span class="o">(</span><span class="n">extensionClasses</span><span class="o">,</span> <span class="no">DUBBO_DIRECTORY</span><span class="o">,</span> <span class="n">type</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">replace</span><span class="o">(</span><span class="s">"org.apache"</span><span class="o">,</span> <span class="s">"com.alibaba"</span><span class="o">));</span>
    <span class="n">loadDirectory</span><span class="o">(</span><span class="n">extensionClasses</span><span class="o">,</span> <span class="no">SERVICES_DIRECTORY</span><span class="o">,</span> <span class="n">type</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="n">loadDirectory</span><span class="o">(</span><span class="n">extensionClasses</span><span class="o">,</span> <span class="no">SERVICES_DIRECTORY</span><span class="o">,</span> <span class="n">type</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">replace</span><span class="o">(</span><span class="s">"org.apache"</span><span class="o">,</span> <span class="s">"com.alibaba"</span><span class="o">));</span>
    
    <span class="c1">// loadExtensionClasses()结束之后，就可以得到所有的扩展类的Class对象</span>
    <span class="c1">// 例如有两个扩展类：</span>
    <span class="c1">//     epson-v1 = com.epson.printer.EpsonV1Printer</span>
    <span class="c1">//     epson-v2 = com.epson.printer.EpsonV2Printer</span>
    <span class="c1">// 就会得到：Map&lt;"epson-v1", Class&lt;EpsonV1Printer&gt;&gt; 和 Map&lt;"epson-v2", Class&lt;EpsonV2Printer&gt;&gt;</span>
    <span class="c1">// 后面如果想要创建某个扩展类的实例，直接通过key获取对应扩展类的Class对象，通过反射就可以创建</span>
    <span class="c1">// 这就与第三步中的createExtension方法中反射创建实例对应起来了</span>
    <span class="k">return</span> <span class="n">extensionClasses</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>loadExtensionClasses()结束之后，就可以得到所有的扩展类的Class对象，而且扩展类的Class对象是以key-value方式缓存起来，后面如果想要创建某个扩展类的实例，直接通过key获取对应扩展类的Class对象，通过反射就可以创建，即可以做到按需加载扩展类，这点比Java SPI要强大。</p>

<h3 id="三dubbo-ioc">三、Dubbo IoC</h3>

<p>Dubbo SPI里面使用到了Dubbo IoC注入依赖，直接来看injectExtension方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="no">T</span> <span class="nf">injectExtension</span><span class="o">(</span><span class="no">T</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">objectFactory</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 遍历目标类的所有方法</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">instance</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethods</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 检测方法是否以 set 开头，且方法仅有一个参数，且方法访问级别为 public</span>
            <span class="c1">// 注明：Dubbo IoC通过setter方法注入依赖</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isSetter</span><span class="o">(</span><span class="n">method</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 如果目标类的方法使用了@DisableInject注解，则该方法不注入</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">DisableInject</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 获取setter方法的第一个参数：只注入第一个参数</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">()[</span><span class="mi">0</span><span class="o">];</span>
            <span class="c1">// 如果该参数是基础数据类型（byte、short、int、long、float、double、boolen、char）：不注入依赖</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">ReflectUtils</span><span class="o">.</span><span class="na">isPrimitives</span><span class="o">(</span><span class="n">pt</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 获取需要注入的字段名</span>
                <span class="c1">// 例如目标类依赖了 private FooObj fooObj;</span>
                <span class="c1">// 则对应的setter方法为：setFooObj(FooObj fooObj)</span>
                <span class="c1">// getSetterProperty(method) 最终返回 "fooObj"</span>
                <span class="nc">String</span> <span class="n">property</span> <span class="o">=</span> <span class="n">getSetterProperty</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
                <span class="c1">// 从应用的上下文环境获取 FooObj 的实例：fooObj</span>
                <span class="nc">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="n">objectFactory</span><span class="o">.</span><span class="na">getExtension</span><span class="o">(</span><span class="n">pt</span><span class="o">,</span> <span class="n">property</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">object</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 通过反射调用setter方法，将 FooObj 的实例：fooObj 注入目标类，完成依赖注入</span>
                    <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">object</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"Failed to inject via method "</span> <span class="o">+</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span>
                        <span class="o">+</span> <span class="s">" of interface "</span> <span class="o">+</span> <span class="n">type</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里来看看Dubbo IoC如何从应用的上下文环境获取 FooObj 的实例：fooObj</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ExtensionLoader类的成员变量</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">ExtensionFactory</span> <span class="n">objectFactory</span><span class="o">;</span>

<span class="c1">// ExtensionLoader类的私有构造函数</span>
<span class="kd">private</span> <span class="nf">ExtensionLoader</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">type</span> <span class="o">=</span> <span class="n">type</span><span class="o">;</span>
    <span class="c1">// ExtensionFactory也是一个Dubbo SPI接口，也是通过SPI方式加载来的</span>
    <span class="n">objectFactory</span> <span class="o">=</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">ExtensionFactory</span><span class="o">.</span><span class="na">class</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nc">ExtensionLoader</span><span class="o">.</span><span class="na">getExtensionLoader</span><span class="o">(</span><span class="nc">ExtensionFactory</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getAdaptiveExtension</span><span class="o">());</span>
<span class="o">}</span>
    
<span class="c1">// 这个就是从应用上下文环境获取到所依赖的类的实例</span>
<span class="nc">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="n">objectFactory</span><span class="o">.</span><span class="na">getExtension</span><span class="o">(</span><span class="n">pt</span><span class="o">,</span> <span class="n">property</span><span class="o">);</span>
</code></pre></div></div>

<p>Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。</p>

<hr />

<p>参考：</p>

<ul>
  <li><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/dubbo-spi/" target="_blank">Dubbo SPI</a></li>
</ul>

</content>
      <pubDate>Sat, 14 Dec 2019 12:52:22 +0000</pubDate>
      <gui>/2019/12/14/dubbo-spi.html</gui>
    </item>
  
    <item>
      <title>MySQL分页+排序数据重复的问题</title>
      <link>/2019/12/12/order-by-limit.html</link>
      <content><p>最近遇到一个MySQL分页+排序时，MySQL返回数据重复的问题，记录一下场景和自己当时的理解。</p>

<h3 id="1-问题mysql-57">1. 问题(<code class="language-plaintext highlighter-rouge">MySQL 5.7</code>)</h3>

<p>有一张数据表：业务线数据表 <code class="language-plaintext highlighter-rouge">business_line</code> 的内容如下：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">1</span>        <span class="o">|</span>         <span class="mi">10</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">10</span><span class="p">:</span><span class="mi">47</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">2</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">21</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">3</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">22</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">4</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">4</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">5</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">6</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">6</span>        <span class="o">|</span>         <span class="mi">11</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">25</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">7</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">7</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">26</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">8</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">8</span>        <span class="o">|</span>         <span class="mi">11</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">27</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">9</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">9</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">28</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">10</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">10</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">30</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">11</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">11</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">34</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">12</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">12</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">37</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">created_time</code>字段设计为<code class="language-plaintext highlighter-rouge">DEFAULT CURRENT_TIMESTAMP</code>，且由于表中的数据是使用<code class="language-plaintext highlighter-rouge">INSERT</code>语句批量一次性插入数据表中，所以每一行数据中的<code class="language-plaintext highlighter-rouge">created_time</code>字段值都是<code class="language-plaintext highlighter-rouge">2019-12-10 11:07:04</code>，这是前提。</p>
</blockquote>

<p>我的需求是在前端页面使用分页 + 按<code class="language-plaintext highlighter-rouge">created_time</code>降序排序的查询规则来查询并展示这个表的数据，分页语句为：<code class="language-plaintext highlighter-rouge">SELECT * FROM business_line ORDER BY created_time DESC LIMIT #{count} OFFSET #{offset};</code></p>

<p>现在查询第一页的数据（每页10条，offset为 0）：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">created_time</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span> <span class="k">OFFSET</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="mi">12</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">12</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">37</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">10</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">10</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">30</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">9</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">9</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">28</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">8</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">8</span>        <span class="o">|</span>         <span class="mi">11</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">27</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">7</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">7</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">26</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">6</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">6</span>        <span class="o">|</span>         <span class="mi">11</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">25</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">5</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">4</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">4</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">3</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">22</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">2</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">21</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
</code></pre></div></div>

<p>嗯 … 看着好像没啥问题。继续查询第二页数据（每页10条，offset为 10）：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">created_time</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span> <span class="k">OFFSET</span> <span class="mi">10</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">2</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">21</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">12</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">12</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">37</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
</code></pre></div></div>

<p>问题来了：第二页居然查出重复的数据，已知<code class="language-plaintext highlighter-rouge">业务线2</code>和<code class="language-plaintext highlighter-rouge">业务线12</code>在第一页查询的时候已经查出来了。总共就两页数据，反倒是<code class="language-plaintext highlighter-rouge">业务线1</code>和<code class="language-plaintext highlighter-rouge">业务线11</code>始终没有查出来！多么窒息的操作 …</p>

<h3 id="2-问题原因追踪">2. 问题原因追踪</h3>

<p>翻阅MySQL官网使用手册，在 <a href="https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html">8.2.1.17 LIMIT Query Optimization</a> 一章中找到一些原因：</p>

<blockquote>
  <p>If multiple rows have identical values in the ORDER BY columns, the server is free to return those rows in any order, and may do so differently depending on the overall execution plan. In other words, the sort order of those rows is nondeterministic with respect to the nonordered columns.</p>
</blockquote>

<p>这里意思是，如果 ORDER BY 所指定的排序字段中存在多行的值相同（就是上述遇到的情况），针对未指定排序的字段，MySQL返回的结果行数据的顺序是不确定的。既然返回的数据顺序不确定，那么在LIMIT取数据的时候，就有可能取到重复的数据，这就解释了我们遇到的情况为什么是这样的。可能MySQL就是这样设计的吧🤷‍♂️🤷‍♂️🤷‍♂️。</p>

<p>另一个影响数据顺序的因素是LIMIT子句，ORDER BY的时候，后面有LIMIT和没有LIMIT时返回数据的顺序是不一样的。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 注意：ORDER BY 后面没有跟 LIMIT 语句时返回的数据顺序：</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">created_time</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">1</span>        <span class="o">|</span>         <span class="mi">10</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">10</span><span class="p">:</span><span class="mi">47</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">11</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">11</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">34</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">10</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">10</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">30</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">9</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">9</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">28</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">8</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">8</span>        <span class="o">|</span>         <span class="mi">11</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">27</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">7</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">7</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">26</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">6</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">6</span>        <span class="o">|</span>         <span class="mi">11</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">25</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">5</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">4</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">4</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">3</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">22</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">2</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">21</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">12</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">12</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">37</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>

<span class="c1">-- ORDER BY 后面跟 LIMIT 语句时返回的数据顺序：</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">created_time</span> <span class="k">LIMIT</span> <span class="mi">5</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="mi">12</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">12</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">37</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">2</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">21</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">3</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">22</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">4</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">4</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">5</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
</code></pre></div></div>

<h3 id="3-问题解决方案">3. 问题解决方案</h3>

<p>当指定的排序字段存在多行数据中的值都一样的情况，MySQL的排序可能就会包含不确定性，就像问题中描述的现象一样：分页返回了重复的数据。为了消除这种不确定性，保证返回的数据顺序是确定的，可以额外使用其他具有唯一性的字段作为排序字段，例如自增ID。</p>

<p>所以根据上述问题中的场景，既然指定的排序字段 <code class="language-plaintext highlighter-rouge">created_time</code> 已经不可避免地在每行数据中包含了相同的值，那需要再额外使用一个其值具备唯一性的字段自增ID来作为排序字段，得到的分页结果将会是跟预期一样正常了。</p>

<p>现在查询第一页的数据（每页10条，offset为 0），注意额外加了 <code class="language-plaintext highlighter-rouge">id</code> 作为排序字段：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">created_time</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">id</span> <span class="k">LIMIT</span> <span class="mi">10</span> <span class="k">OFFSET</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">1</span>        <span class="o">|</span>         <span class="mi">10</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">10</span><span class="p">:</span><span class="mi">47</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">2</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">21</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">3</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">22</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">4</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">4</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">23</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">5</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">6</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">6</span>        <span class="o">|</span>         <span class="mi">11</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">25</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">7</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">7</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">26</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">8</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">8</span>        <span class="o">|</span>         <span class="mi">11</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">27</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">9</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">9</span>        <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">28</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">10</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">10</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">30</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
</code></pre></div></div>

<p>继续查询第二页数据（每页10条，offset为 10），注意额外加了 <code class="language-plaintext highlighter-rouge">id</code> 作为排序字段：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">created_time</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">id</span> <span class="k">LIMIT</span> <span class="mi">10</span> <span class="k">OFFSET</span> <span class="mi">10</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="mi">11</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">11</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">34</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">12</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">12</span>       <span class="o">|</span>          <span class="mi">1</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">10</span> <span class="mi">11</span><span class="p">:</span><span class="mi">07</span><span class="p">:</span><span class="mi">04</span> <span class="o">|</span> <span class="mi">2019</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">12</span> <span class="mi">11</span><span class="p">:</span><span class="mi">41</span><span class="p">:</span><span class="mi">37</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
</code></pre></div></div>

<p>至此，分页数据重复的问题得到解决。</p>

<p><code class="language-plaintext highlighter-rouge">ORDER BY created_time DESC, id</code> 语句中，MySQL会优先使用 <code class="language-plaintext highlighter-rouge">created_time</code> 字段进行降序排序，当遇到 <code class="language-plaintext highlighter-rouge">created_time</code> 字段值一样时，会使用 <code class="language-plaintext highlighter-rouge">id</code> 进行升序排序（不指定则默认<code class="language-plaintext highlighter-rouge">ASC</code>），从而解决了 ORDER BY + LIMIT 组合使用时分页数据重复的问题了。</p>

<h3 id="4-后续补充">4. 后续补充</h3>

<p>MySQL 8.0 + 的版本已经不存在上述的问题。现在以MySQL 8.0版本来做实验，现在表中数据如下：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">1</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">2</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">3</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">4</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">4</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">5</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">6</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">6</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">7</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">7</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">8</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">8</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">9</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">9</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">10</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">10</span>       <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">11</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">11</span>       <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">12</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">12</span>       <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
</code></pre></div></div>

<p>现在查询第一页的数据（每页10条，offset为 0）：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">created_time</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span> <span class="k">OFFSET</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">1</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">2</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">3</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">4</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">4</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">5</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">5</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">6</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">6</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">7</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">7</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">8</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">8</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span>  <span class="mi">9</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">9</span>        <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">10</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">10</span>       <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
</code></pre></div></div>

<p>再查询第二页的数据每页10条，offset为 10）：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">business_line</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">created_time</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span> <span class="k">OFFSET</span> <span class="mi">10</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">buz_line_name</span> <span class="o">|</span> <span class="n">company_id</span> <span class="o">|</span> <span class="n">status</span> <span class="o">|</span> <span class="n">created_time</span>        <span class="o">|</span> <span class="n">updated_time</span>        <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
<span class="o">|</span> <span class="mi">11</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">11</span>       <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">12</span> <span class="o">|</span> <span class="err">业务线</span><span class="mi">12</span>       <span class="o">|</span>          <span class="mi">0</span> <span class="o">|</span>      <span class="mi">0</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span> <span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">08</span> <span class="mi">04</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span><span class="mi">24</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+---------------+------------+--------+---------------------+---------------------+</span>
</code></pre></div></div>

<p>从结果上看，MySQL 8.0版本已经默认处理了这种情况，即如果排序字段值相同，则会再根据自增ID进行排序。</p>

<p>然而在官方的手册文档上，关于这部分的说明仍跟5.7版本一样：<a href="https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html">8.2.1.19 LIMIT Query Optimization</a>，不知道为何，也许文档没来得及修改？</p>

<hr />

</content>
      <pubDate>Thu, 12 Dec 2019 03:03:43 +0000</pubDate>
      <gui>/2019/12/12/order-by-limit.html</gui>
    </item>
  
    <item>
      <title>MyBatis的缓存机制</title>
      <link>/2019/10/16/mybatis-cache.html</link>
      <content><p>todo.</p>

<hr />

<p>参考：</p>
</content>
      <pubDate>Wed, 16 Oct 2019 12:00:00 +0000</pubDate>
      <gui>/2019/10/16/mybatis-cache.html</gui>
    </item>
  
    <item>
      <title>Java SPI</title>
      <link>/2019/10/12/java-spi.html</link>
      <content><h3 id="1-spi机制介绍与使用">1. SPI机制介绍与使用</h3>

<p>Java SPI是Java用于构建具备可扩展性的应用的一种机制。所谓的具备可扩展性，就是可以通过某种方式让使用者在不更改这个应用源代码的基础上去在这个应用上添加新的功能特性。</p>

<p>先看看三个概念：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Service</code>：就是具备可扩展性的应用服务，可扩展的对外接口就是由它定义；</li>
  <li><code class="language-plaintext highlighter-rouge">Service provider interface (SPI)</code>：Service定义的一组开放的接口，称为SPI接口；</li>
  <li><code class="language-plaintext highlighter-rouge">Service Provider</code>：服务提供者，负责实现SPI接口，提供具体的实现。例如生产商。</li>
</ul>

<p>Service定义SPI接口并以<code class="language-plaintext highlighter-rouge">jar</code>包的方式对外发布。若第三方（Service Provider）想在Service应用上实现自己想要的特性，那Service Provider就可以引入这个<code class="language-plaintext highlighter-rouge">SPI jar</code>包，并提供自己的实现。</p>

<p><img src="/static/image/2019/java-spi-workflow.png" alt="spi" /></p>

<p>上图就是SPI机制的运作流程。接下来介绍Service如何发现并加载Service Provider提供的SPI接口的实现。</p>

<p>假设有一个Service：打印机服务应用，对用户提供打印服务。这个打印机服务应用很强大，可以做到适配任何厂家的打印设备，因为这个打印服务应用在设计的时候考虑到了可扩展性。</p>

<p>这个打印服务应用定义的一个标准SPI接口：<code class="language-plaintext highlighter-rouge">com.loji44.spi.Printer</code>，这个接口会以jar包的方式对外发布。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.loji44.spi</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Printer</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>然后有一个打印机设备厂商佳能引入这个jar包依赖，并提供自己的实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.canon.printer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.loji44.spi.Printer</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CanonPrinter</span> <span class="kd">implements</span> <span class="nc">Printer</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"佳能打印机为您服务："</span> <span class="o">+</span> <span class="n">text</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"佳能打印机为您服务："</span> <span class="o">+</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>做好实现后，根据SPI机制的规范，佳能厂商需要在自己源代码的<code class="language-plaintext highlighter-rouge">src/main/resources/META-INF/services</code>目录下新建一个名为SPI接口全限定名的文本文件，里面的内容为自己实现类的全限定名，如下图所示：</p>

<p><img src="/static/image/2019/spi-canon-provider.png" alt="spi-canon-provider" /></p>

<p>接下来，打印服务应用（Service）引入佳能厂商提供的实现jar包（例如通过Maven引入）：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.canon<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>canon-printer<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.0.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>引入了佳能厂商提供的实现jar包依赖之后，就可以加载并使用佳能打印设备提供的打印服务了：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ServiceLoader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.loji44.spi.Printer</span><span class="o">;</span>

<span class="c1">// 我是打印机服务应用，这里是启动打印服务的入口</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrinterLauncher</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="nc">Printer</span><span class="o">&gt;</span> <span class="n">serviceLoader</span> <span class="o">=</span> <span class="nc">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Printer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">serviceLoader</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">printer</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">printer</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"我要打印很多钱"</span><span class="o">);</span>
        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 运行结果</span>
<span class="n">佳能打印机为您服务</span><span class="err">：</span><span class="n">我要打印很多钱</span>
</code></pre></div></div>

<p>我们在没有修改打印机服务应用（PrinterLauncher）的源代码的情况下，通过SPI扩展机制成功使用了佳能的打印设备！</p>

<p>同样的，如果有另一家打印机设备厂商（例如惠普）以同样的做法提供了自己的实现，那么打印机服务应用（PrinterLauncher）同样只需要引入惠普厂商提供的实现jar包依赖，就可以使用其提供的打印服务。这就是我们说的功能扩展了。</p>

<h3 id="2-spi发现与加载的奥秘">2. SPI发现与加载的奥秘</h3>

<p>在上一节中，我们通过以下几行代码就可以发现、加载并使用服务提供商提供的SPI实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="nc">Printer</span><span class="o">&gt;</span> <span class="n">serviceLoader</span> <span class="o">=</span> <span class="nc">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Printer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">serviceLoader</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">printer</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">printer</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"我要打印很多钱"</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<p>没错，Java SPI服务提供商提供的实现是通过<code class="language-plaintext highlighter-rouge">java.util.ServiceLoader</code>这个类来完成查找、加载并使用的。我们来看看它是如何查找并加载SPI实现类的：</p>

<ul>
  <li>ServiceLoader.load(Printer.class)</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="nf">load</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ClassLoader</span> <span class="n">cl</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">();</span>
    <span class="k">return</span> <span class="nc">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">service</span><span class="o">,</span> <span class="n">cl</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><em>ClassLoader cl = Thread.currentThread().getContextClassLoader()</em> 这行代码是获取当前线程的线程上下文类加载器，用来加载厂商提供的实现类（类加载肯定是由类加载器来完成）。</p>

<p>这里为什么要使用线程上下文类加载器，而不是使用其他类加载器，例如启动类加载器（Bootstrap Classloader）或者扩展类加载器（Extension Classloader）</p>

<p>首先，我们要明确：</p>

<ul>
  <li>启动类加载器（Bootstrap Classloader）只会加载<code class="language-plaintext highlighter-rouge">JAVA_HOME/lib</code>目录下的Java基础类库，而且只会加载名字符合的类库，例如<code class="language-plaintext highlighter-rouge">rt.jar</code>。对于加载范围和类库名称有着严格的要求，所以就算你把自己的jar包放入<code class="language-plaintext highlighter-rouge">JAVA_HOME/lib</code>下面，也不会被启动类加载器加载；</li>
  <li>扩展类加载器（Extension Classloader）也一样，它只会加载<code class="language-plaintext highlighter-rouge">JAVA_HOME/lib/ext</code>目录下的类库；</li>
  <li>应用类加载器（Application Classloader）用来加载用户Classpath下面的类库，即加载我们开发中引入的各种第三方类库。</li>
</ul>

<p>我们知道，线程上下文类加载器是跟线程绑定的，创建线程时，我们可以为该线程设置一个类加载器（即线程上下文类加载器）。如果不设置，线程会自动继承父线程的上下文类加载器，而Java应用运行的初始线程绑定的上下文类加载器就是系统类加载器（Application Classloader）。</p>

<p><code class="language-plaintext highlighter-rouge">java.util.ServiceLoader</code>是<code class="language-plaintext highlighter-rouge">rt.jar</code>类库里面的一个类，肯定是由Bootstrap Classloader加载的。厂商的类其实是放在用户Classpath下面的，让ServiceLoader去加载厂商的类，如果不使用线程上下文类加载器，那么JVM会默认使用加载<code class="language-plaintext highlighter-rouge">java.util.ServiceLoader</code>类的类加载器，即Bootstrap Classloader去加载厂商的类。Bootstrap Classloader是不可能认识厂商类的，因为它只认识<code class="language-plaintext highlighter-rouge">JAVA_HOME/lib</code>目录下的类库，那我要加载厂商的类怎么办？</p>

<p>答案就是Bootstrap Classloader委托应用类加载器（Application Classloader）去加载厂商的类，因为Application Classloader就是专门用来加载用户Classpath的类库的。这里其实破坏了JVM类加载的「双亲委派」模型，即父类加载器委托子类加载器去加载一个类。</p>

<blockquote>
  <p>JVM类加载的「双亲委派」加载模型规定：当JVM收到一个类加载请求，它不会直接加载这个类，而是委托它的父类加载器去加载，每一层都是这样，逐层往上传递请求，直到顶层类加载器Bootstrap Classloader。如果父类加载器加载不到，子类加载器才会自己执行加载动作。</p>
</blockquote>

<p>说了这么多，总结起来就一点：Bootstrap Classloader不认识用户Classpath下的类，那么它就通过线程上下文类加载器来做一些「变通」，因为线程上下文类加载器在没有人为设置过的时候默认就是Application Classloader，这样我就可以加载到厂商的类了。</p>

<blockquote>
  <p>可能有人又要问：那为什么<code class="language-plaintext highlighter-rouge">java.util.ServiceLoader</code>不直接指定Application Classloader去加载厂商的类，而非要通过线程上下文类加载器去转一道？<br />
代码直接写死指定使用Application Classloader也可以，但是丧失了灵活性。作为基础通用的框架，你要留给用户一个选择的余地，因为通过线程上下文类加载器，用户是可以设置这个线程使用其他类加载器的，例如用户的程序里面自定义了其他类加载器。</p>
</blockquote>

<p>好了，关于加载厂商类的类加载器相关内容就说到这里。继续我们的 <em>ServiceLoader.load</em>，其实最终就是<code class="language-plaintext highlighter-rouge">new</code>一个ServiceLoader的实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="nf">load</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">service</span><span class="o">,</span> <span class="nc">ClassLoader</span> <span class="n">loader</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">ServiceLoader</span><span class="o">&lt;&gt;(</span><span class="n">service</span><span class="o">,</span> <span class="n">loader</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>来看看ServiceLoader的私有构造器：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 将要被加载的SPI接口类的Class对象，例如 Printer.class</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">service</span><span class="o">;</span>
    <span class="c1">// 用于加载SPI服务提供商提供的实现类的类加载器</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">ClassLoader</span> <span class="n">loader</span><span class="o">;</span>
    <span class="c1">// SPI服务提供商提供的实现类的实例的缓存：加载到并实例化后，缓存起来</span>
    <span class="kd">private</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">providers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// ServiceLoader自己实现的一个懒加载的迭代器：这个是重点</span>
    <span class="kd">private</span> <span class="nc">LazyIterator</span> <span class="n">lookupIterator</span><span class="o">;</span>
        
    <span class="c1">// 私有构造器    </span>
    <span class="kd">private</span> <span class="nf">ServiceLoader</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">svc</span><span class="o">,</span> <span class="nc">ClassLoader</span> <span class="n">cl</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">service</span> <span class="o">=</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">svc</span><span class="o">,</span> <span class="s">"Service interface cannot be null"</span><span class="o">);</span>
        <span class="n">loader</span> <span class="o">=</span> <span class="o">(</span><span class="n">cl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="nc">ClassLoader</span><span class="o">.</span><span class="na">getSystemClassLoader</span><span class="o">()</span> <span class="o">:</span> <span class="n">cl</span><span class="o">;</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="nc">AccessController</span><span class="o">.</span><span class="na">getContext</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">reload</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>ServiceLoader私有构造器里面前面三行代码主要做一些初始化检查工作，重点在于reload()方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">reload</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">providers</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
    <span class="n">lookupIterator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LazyIterator</span><span class="o">(</span><span class="n">service</span><span class="o">,</span> <span class="n">loader</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>先清理之前加载过的实现类，即每次调用ServiceLoader.load的时候，都会保证清理之前加载的实现类缓存；</li>
  <li>初始化一个懒加载的迭代器。</li>
</ul>

<p>到这里ServiceLoader.load其实就走完了，可以看到ServiceLoader.load其实不是真正去查找、加载厂商的实现类，而是做一些初始化的工作，其中最重要的就是初始化一个LazyIterator。</p>

<p>那厂商的实现类在什么时候进行查找、加载呢？</p>

<p>答案是在使用的时候才进行实现类的加载：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="nc">Printer</span><span class="o">&gt;</span> <span class="n">serviceLoader</span> <span class="o">=</span> <span class="nc">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Printer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">serviceLoader</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">printer</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">printer</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"我要打印很多钱"</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<p>刚才说了，调用ServiceLoader.load的时候会初始化一个LazyIterator，当我们使用serviceLoader.forEach去遍历厂商实现类的时候，其实就是查找并加载厂商的实现类。</p>

<p>LazyIterator是ServiceLoader的一个内部类，它实现了<code class="language-plaintext highlighter-rouge">Iterator</code>接口，用于迭代加载实现类。先来看LazyIterator的nextService方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="no">S</span> <span class="nf">nextService</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">hasNextService</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
    
    <span class="nc">String</span> <span class="n">cn</span> <span class="o">=</span> <span class="n">nextName</span><span class="o">;</span>
    <span class="n">nextName</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="n">c</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">cn</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">loader</span><span class="o">);</span>
    <span class="c1">// 此处省略不重要的代码 ...</span>
    <span class="no">S</span> <span class="n">p</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">cast</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">());</span>
    <span class="n">providers</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cn</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
    <span class="c1">// 此处省略不重要的代码 ...</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>nextService方法做了四件事情：</p>

<ul>
  <li>调用hasNextService方法来判断是不是还有可迭代的实现类。这里注意，如果是首次调用hasNextService方法，hasNextService会去查找<code class="language-plaintext highlighter-rouge">META-INF/services</code>下面以SPI接口全限定名命名的文本文件并逐行读取文件内容，放入一个叫pending的缓存变量。后面每次迭代调用hasNextService时，都直接从缓存中获取下一行的内容放入nextName变量返回；</li>
  <li>nextName就是实现类的全限定名，nextService方法中调用Class.forName来加载此实现类，传入的loader就是我们之前说的线程上下文类加载器（默认为Application Classloader）；</li>
  <li>如果成功加载，则通过反射创建该实现类的实例；</li>
  <li>将该实现类的实例缓存到providers这个Map变量中，后续再迭代，就会直接从缓存中获取，不会再创建实例了。</li>
</ul>

<p>hasNextService方法其实就是会在首次调用的时候去读取以SPI接口全限定名命名的文本文件，读取文件中的每一行内容，因为每一行就代表一个实现类（厂商可以提供多个实现类），并将每一个实现类的全限定名保存到一个pending变量中。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">class</span> <span class="nc">LazyIterator</span> <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nc">Class</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">service</span><span class="o">;</span>
    <span class="nc">ClassLoader</span> <span class="n">loader</span><span class="o">;</span>
    <span class="nc">Enumeration</span><span class="o">&lt;</span><span class="no">URL</span><span class="o">&gt;</span> <span class="n">configs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pending</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">nextName</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">hasNextService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">configs</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 这里的PREFIX就是 "META-INF/services/"</span>
                <span class="c1">// fullName在这里就是 "META-INF/services/com.loji44.spi.Printer"</span>
                <span class="nc">String</span> <span class="n">fullName</span> <span class="o">=</span> <span class="no">PREFIX</span> <span class="o">+</span> <span class="n">service</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">loader</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">configs</span> <span class="o">=</span> <span class="nc">ClassLoader</span><span class="o">.</span><span class="na">getSystemResources</span><span class="o">(</span><span class="n">fullName</span><span class="o">);</span>
                <span class="k">else</span>
                    <span class="c1">// 读取文件资源</span>
                    <span class="c1">// 这就是为什么要求提供实现的厂商在 "src/main/resources/META-INF/services" 下创建以SPI接口全限定名为文件名的文本文件</span>
                    <span class="n">configs</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="na">getResources</span><span class="o">(</span><span class="n">fullName</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">fail</span><span class="o">(</span><span class="n">service</span><span class="o">,</span> <span class="s">"Error locating configuration files"</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">pending</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pending</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">configs</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 逐行解析 com.loji44.spi.Printer 文件内容</span>
            <span class="n">pending</span> <span class="o">=</span> <span class="n">parse</span><span class="o">(</span><span class="n">service</span><span class="o">,</span> <span class="n">configs</span><span class="o">.</span><span class="na">nextElement</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">// 文件中每一行内容就是一个实现类的全限定名</span>
        <span class="n">nextName</span> <span class="o">=</span> <span class="n">pending</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>总结一下：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ServiceLoader.load</code>只是初始化了加载实现类所需要的一些参数；</li>
  <li>当使用<code class="language-plaintext highlighter-rouge">serviceLoader.forEach</code>去迭代实现类的实例的时候，才会真正触发厂商实现类的查找、加载。</li>
</ul>

<h3 id="3-spi机制的应用">3. SPI机制的应用</h3>

<p>Java SPI在实际中有很多应用，例如我们提到的打印机的例子。</p>

<p>还有一些更常用的例如JDK的数据库驱动管理。JDK里面定义了一个标准的数据库驱动的接口<code class="language-plaintext highlighter-rouge">java.sql.Driver</code>让各个数据库厂商（例如MySQL、PostgreSQL）去提供自己的实现。各个数据库厂商只需要遵循<code class="language-plaintext highlighter-rouge">java.sql.Driver</code>接口的规范来开发自己的驱动，然后用户在使用的时候只需要引入各个数据库厂商的jar包依赖即可使用对应的数据库。</p>

<p>最后，JDK还提供了一个类来加载、管理各个厂商的数据库驱动：<code class="language-plaintext highlighter-rouge">java.sql.DriverManager</code>，而DriverManager里面正是使用SPI的ServiceLoader来完成驱动的加载的。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">java.sql.DriverManager</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DriverManager</span> <span class="o">{</span>
    <span class="c1">// ... ...</span>
    
    <span class="kd">static</span> <span class="o">{</span>
        <span class="c1">// DriverManager在类加载阶段就会去加载并初始化数据库驱动</span>
        <span class="n">loadInitialDrivers</span><span class="o">();</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"JDBC DriverManager initialized"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// ... ... </span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loadInitialDrivers</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// ... ...</span>
        
        <span class="c1">// 如果Driver是以SPI的Service Provider方式提供，就使用ServiceLoader来加载Driver</span>
        <span class="nc">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">(</span><span class="k">new</span> <span class="nc">PrivilegedAction</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="nc">Void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="nc">Driver</span><span class="o">&gt;</span> <span class="n">loadedDrivers</span> <span class="o">=</span> <span class="nc">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Driver</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Driver</span><span class="o">&gt;</span> <span class="n">driversIterator</span> <span class="o">=</span> <span class="n">loadedDrivers</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
                <span class="k">try</span><span class="o">{</span>
                    <span class="c1">// 执行迭代：真正触发驱动类的查找和加载、实例化</span>
                    <span class="k">while</span><span class="o">(</span><span class="n">driversIterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">driversIterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Do nothing</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>

       <span class="c1">// ... ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>再看看MySQL提供的实现类的jar包里面：没错，就是标准的SPI方式提供的实现了。</p>

<p><img src="/static/image/2019/mysql-driver.png" alt="mysql-driver" /></p>

<h3 id="4-写在最后">4. 写在最后</h3>

<ul>
  <li>ServiceLoader实例是线程不安全的，多个线程同时迭代查找、加载实现类的时候，里面并没有任何同步措施；</li>
  <li>SPI虽说使用的是懒加载迭代器，但是在执行迭代的时候，不管用没用到对应的实现，SPI都会全部加载、创建实例，而不能根据我们所需指定加载某个实现类。</li>
</ul>

<hr />

</content>
      <pubDate>Sat, 12 Oct 2019 11:10:48 +0000</pubDate>
      <gui>/2019/10/12/java-spi.html</gui>
    </item>
  
    <item>
      <title>Java中的代理机制</title>
      <link>/2019/10/10/java-proxy.html</link>
      <content><h3 id="1-为什么要使用代理">1. 为什么要使用代理</h3>

<p>代理对象可以对目标对象的间接访问，即通过代理访问目标对象。这样就可以在不修改（不入侵）目标实现的基础上对目标对象的功能进行增强，例如在在目标对象的方法前后加上额外的功能代码。</p>

<h3 id="2-jdk静态代理">2. JDK静态代理</h3>

<p>例如有一个售票处的接口：包含售票方法（<code class="language-plaintext highlighter-rouge">sellTicket</code>）和退票方法（<code class="language-plaintext highlighter-rouge">refundTicket</code>）</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TicketOffice</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">sellTicket</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">refundTicket</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>目标对象的实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TicketOfficeImpl</span> <span class="kd">implements</span> <span class="nc">TicketOffice</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sellTicket</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"正在售票 ..."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">refundTicket</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"正在退票 ..."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>若要在售票之前做一些必要的检查，比如核实用户的身份证和实名信息。我们可以怎么做？首先想到的可能就是直接修改目标对象的方法，在售票之前加上校验的逻辑，例如下面：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TicketOfficeImpl</span> <span class="kd">implements</span> <span class="nc">TicketOffice</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sellTicket</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"正在核实用户的身份证和实名信息 ..."</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"正在售票 ..."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这种做法简单粗暴，在业务不复杂的时候用起来也还OK。但是如果<code class="language-plaintext highlighter-rouge">TicketOffice</code>接口有很多目标实现类，比如夸张点1000个，那岂不是要一个个目标类改过去<code class="language-plaintext highlighter-rouge">:(</code>。而且这种直接修改目标对象，入侵目标对象的代码有时候是无法做到的，比如你是用的是第三方的jar包引入的一个接口和目标实现，你就无法直接修改它的实现来完成功能增强。</p>

<p>在进一步考虑，可以使用JDK的静态代理。</p>

<blockquote>
  <p>静态代理的实现：编写一个<strong>代理对象</strong>，跟<strong>目标对象</strong>实现相同的接口，并在<strong>代理对象</strong>内部维护一个<strong>目标对象</strong>的引用，然后通过构造器注入<strong>目标对象</strong>的实例。最后在<strong>代理对象</strong>中调用目标对象的同名方法来完成代理。</p>
</blockquote>

<p>下面写一个代理类<code class="language-plaintext highlighter-rouge">TicketOfficeProxy</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TicketOfficeProxy</span> <span class="kd">implements</span> <span class="nc">TicketOffice</span> <span class="o">{</span>
    <span class="c1">// 代理类内部维护一个目标对象的引用</span>
    <span class="kd">private</span> <span class="nc">TicketOffice</span> <span class="n">ticketOffice</span><span class="o">;</span>
    
    <span class="c1">// 构造器注入目标对象实例</span>
    <span class="kd">public</span> <span class="nf">TicketOfficeProxy</span><span class="o">(</span><span class="nc">TicketOffice</span> <span class="n">ticketOffice</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ticketOffice</span> <span class="o">=</span> <span class="n">ticketOffice</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sellTicket</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 在代理对象的sellTicket方法中做额外的功能</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"正在核实用户的身份证和实名信息 ..."</span><span class="o">);</span>
        <span class="c1">// 调用目标对象的同名方法</span>
        <span class="n">ticketOffice</span><span class="o">.</span><span class="na">sellTicket</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 构建代理对象实例：将目标对象实例通过构造器注入</span>
        <span class="nc">TicketOfficeProxy</span> <span class="n">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TicketOfficeProxy</span><span class="o">(</span><span class="k">new</span> <span class="nc">TicketOfficeImpl</span><span class="o">());</span>
        <span class="c1">// 调用代理类的方法，会映射到目标类的同名方法</span>
        <span class="n">proxy</span><span class="o">.</span><span class="na">sellTicket</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>静态代理做到了在不修改（不入侵）目标对象代码的情况下，对目标对象进行拦截和功能扩展。</p>

<blockquote>
  <p>JDK静态代理：为了保证代理类可以和目标类的结构（方法）保持一致，从而在调用代理对象的时候可以最终映射到目标对象的同名方法，那么代理对象必须跟目标对象实现同一个接口。</p>
</blockquote>

<p>静态代理也有局限性：如果有很多个目标类需要进行代理，而且每个目标类实现的接口都不一样，就需要为每个目标类都写一个代理类 <code class="language-plaintext highlighter-rouge">:(</code></p>

<p><img src="/static/image/2019/static_proxy.png" alt="static_proxy" /></p>

<p>到这里我们可以发现，所谓静态代理就是需要我们手工一个个将所需要的代理类“码”出来，然后经过编译器编译成<code class="language-plaintext highlighter-rouge">.class</code>文件。这是很麻烦的，有没有可能在我们需要用到代理对象的时候，JVM在运行时帮我们自动生成代理对象呢？</p>

<p>静态代理没法做到，但是JDK动态代理可以！</p>

<h3 id="3-jdk动态代理">3. JDK动态代理</h3>

<p>JDK静态代理我们已经知道需要在代码编译之前就要把所有代理类都写好，这个还是非常麻烦的。所以JDK动态代理就做了这么一件事：在运行时自动帮我们生成代理对象！</p>

<p>但是怎么生成呢？</p>

<blockquote>
  <p>我们知道代理对象必须要跟目标对象实现同一个接口，因为这样才能保证调用代理对象的方法时能够最终映射到目标对象的同名方法。</p>
</blockquote>

<p>要创建一个对象的实例，最关键的是要得到对应的Class对象。每个<code class="language-plaintext highlighter-rouge">.class</code>类文件在经过类加载之后，都会在JVM方法区生成一个对应的Class对象。最终<code class="language-plaintext highlighter-rouge">new</code>一个实例的时候就是通过这些Class对象提供的Class类信息来完成的。</p>

<p><img src="/static/image/2019/class.png" alt="class" /></p>

<p>拿到代理对象的Class之后就可以使用Class类提供的反射方法来创建代理对象！</p>

<p>JDK提供<code class="language-plaintext highlighter-rouge">java.lang.reflect.Proxy</code>类和<code class="language-plaintext highlighter-rouge">java.lang.reflect.InvocationHandler</code>接口来实现动态代理：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 封装一个方法，便于直接生成代理对象</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="nf">getProxy</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"目标对象方法执行之前 ..."</span><span class="o">);</span>
                <span class="c1">// 通过反射调用目标对象的方法</span>
                <span class="nc">Object</span> <span class="n">returnObj</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"目标对象方法执行之后 ..."</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">returnObj</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Proxy</code>类提供了一个静态方法<code class="language-plaintext highlighter-rouge">newProxyInstance</code>来生成目标对象的代理对象。而<code class="language-plaintext highlighter-rouge">newProxyInstance</code>正是通过获取传入的目标对象所实现的接口的Class对象（<code class="language-plaintext highlighter-rouge">target.getClass().getInterfaces()</code>）来“拷贝”类的结构信息（主要是方法描述信息），用于构建代理对象的Class对象。最后再通过代理对象的Class对象的反射机制，创建出代理对象的实例。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">constructorParams</span> <span class="o">=</span> <span class="o">{</span> <span class="nc">InvocationHandler</span><span class="o">.</span><span class="na">class</span> <span class="o">};</span>
    
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="nf">newProxyInstance</span><span class="o">(</span><span class="nc">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span><span class="o">,</span> <span class="nc">InvocationHandler</span> <span class="n">h</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IllegalArgumentException</span> <span class="o">{</span>
        <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>

        <span class="c1">// 拷贝目标对象所实现的接口的Class对象信息</span>
        <span class="kd">final</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">intfs</span> <span class="o">=</span> <span class="n">interfaces</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
        <span class="kd">final</span> <span class="nc">SecurityManager</span> <span class="n">sm</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sm</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">checkProxyAccess</span><span class="o">(</span><span class="nc">Reflection</span><span class="o">.</span><span class="na">getCallerClass</span><span class="o">(),</span> <span class="n">loader</span><span class="o">,</span> <span class="n">intfs</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 这里是重点：根据接口的Class信息创建出代理对象的Class对象</span>
        <span class="c1">// 最终这里可以生成我们所需要的代理对象的Class对象，有了Class对象我们就通过反射创建代理对象了！</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">cl</span> <span class="o">=</span> <span class="n">getProxyClass0</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">intfs</span><span class="o">);</span>
        
        <span class="c1">// ... ...</span>
 
        <span class="kd">final</span> <span class="nc">Constructor</span><span class="o">&lt;?&gt;</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="n">constructorParams</span><span class="o">);</span>
        
        <span class="c1">// ... ...</span>
        
        <span class="k">return</span> <span class="n">cons</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">h</span><span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">cons.newInstance(new Object[]{h})</code>在使用代理对象的构造器创建代理对象时，会将<code class="language-plaintext highlighter-rouge">InvocationHandler</code>传进去。这样在调用代理对象的方法时，最终都会调用到<code class="language-plaintext highlighter-rouge">InvocationHandler</code>的<code class="language-plaintext highlighter-rouge">invoke</code>方法。而<code class="language-plaintext highlighter-rouge">invoke</code>方法里面使用反射<code class="language-plaintext highlighter-rouge">method.invoke(target, args)</code>来调用目标对象的方法，这就完成了代理。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 这样只需要调用getProxy方法并传入目标对象的实例，就可以返回该目标对象的代理对象</span>
        <span class="nc">TicketOffice</span> <span class="n">ticketOffice</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TicketOffice</span><span class="o">)</span> <span class="n">getProxy</span><span class="o">(</span><span class="k">new</span> <span class="nc">TicketOfficeImpl</span><span class="o">());</span>
        <span class="n">ticketOffice</span><span class="o">.</span><span class="na">sellTicket</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"代理对象的类名："</span> <span class="o">+</span> <span class="n">ticketOffice</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"代理对象的父类名："</span> <span class="o">+</span> <span class="n">ticketOffice</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSuperclass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 运行结果</span>
<span class="n">目标对象方法执行之前</span> <span class="o">...</span>
<span class="n">正在售票</span> <span class="o">...</span>
<span class="n">目标对象方法执行之后</span> <span class="o">...</span>
<span class="n">代理对象的类名</span><span class="err">：</span><span class="n">com</span><span class="o">.</span><span class="na">sun</span><span class="o">.</span><span class="na">proxy</span><span class="o">.</span><span class="n">$Proxy3</span>
<span class="n">代理对象的父类名</span><span class="err">：</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">reflect</span><span class="o">.</span><span class="na">Proxy</span>
</code></pre></div></div>

<p>从运行结果来看，动态代理对象确实成功对目标对象进行拦截并完成增强。</p>

<blockquote>
  <p>JVM生成的代理对象类型为<code class="language-plaintext highlighter-rouge">com.sun.proxy.$Proxy3</code>，而代理对象的父类则是<code class="language-plaintext highlighter-rouge">java.lang.reflect.Proxy</code>！</p>
</blockquote>

<p>上面提到，在生成代理对象的时候会从构造器传入一个<code class="language-plaintext highlighter-rouge">java.lang.reflect.InvocationHandler</code>的实例，而<code class="language-plaintext highlighter-rouge">java.lang.reflect.Proxy</code>类里面恰好定义了一个成员变量用于接收<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Proxy</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
    
    <span class="c1">// ... ...</span>
    
    <span class="cm">/**
     * the invocation handler for this proxy instance.
     * @serial
     */</span>
    <span class="kd">protected</span> <span class="nc">InvocationHandler</span> <span class="n">h</span><span class="o">;</span>
   
    <span class="c1">// ... ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>代理对象继承<code class="language-plaintext highlighter-rouge">java.lang.reflect.Proxy</code>之后也就间接拥有了这个<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例，这也就是为什么调用代理对象的方法最终都会调用到<code class="language-plaintext highlighter-rouge">InvocationHandler</code>的<code class="language-plaintext highlighter-rouge">invoke</code>方法，从而转到目标对象的同名方法上去。</p>

<h3 id="4-题外话cglib动态代理">4. 题外话：CGLIB动态代理</h3>

<p>Java的动态代理大体上可以分为JDK动态代理和CGLIB动态代理；</p>

<ul>
  <li>JDK动态代理由JDK自带的动态代理实现，只能代理实现了接口的目标对类；</li>
  <li>CGLIB是一个第三方实现的动态代理，它不仅可以代理实现了接口的目标对类，还能代理普通的类（没有实现接口），因而功能更强大。</li>
</ul>

<blockquote>
  <p>本人对CGLIB底层实现原理不是很了解，这里不会详细介绍CGLIB原理，而是大体说说自己的一些认知。</p>
</blockquote>

<p>CGLIB的原理大致理解为：CGLIB会为要代理的目标类生成一个子类，这个子类就是代理类。子类会重写目标类的所有方法（final修饰的方法除外），从而在子类（代理类）的同名方法中对父类（目标类）的方法进行拦截、调用并做一些增强的代码逻辑。</p>

<p>CGLIB在生成代理类的时候，使用的是字节码处理框架ASM，来转换字节码并生成新的类。</p>

<blockquote>
  <p>虽然CGLIB从功能上确实比JDK动态代理要强，但是它也有自己的局限性。由于是为目标对象生成子类，所以CGLIB不能代理final修饰的类以及final修饰的方法。</p>
</blockquote>

<p>CGLIB动态代理是Java动态代理在发展过程中，为了解决一些JDK动态代理所不能解决的一些问题而衍生出来的。我理解为它是JDK动态代理的一个很好的补充，谈不上替代JDK动态代理。</p>

<p>反而在实际应用中我们会经常看到两种动态代理都会使用到，例如Spring AOP在做代理时，默认情况下，如果目标对象实现了接口，它会使用JDK动态代理来生成代理类；而对于普通类，则默认使用CGLIB动态代理生成代理类。</p>

<p>例如下面的代码：当然这不是Spring AOP的源码，只是为了阐释自己写的一个。大体意思明白就好</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getProxy</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">interfaces</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 目标对象实现了接口：优先使用JDK动态代理生成代理对象</span>
        <span class="k">return</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"JDK动态代理：目标对象方法执行之前 ..."</span><span class="o">);</span>
                    <span class="nc">Object</span> <span class="n">returnObj</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"JDK动态代理：目标对象方法执行之后 ..."</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">returnObj</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
    <span class="o">}</span>

    <span class="c1">// 目标对象没有实现任何接口：使用CGLIB代理生成代理对象</span>
    <span class="nc">Enhancer</span> <span class="n">enhancer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Enhancer</span><span class="o">();</span>
    <span class="n">enhancer</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
    <span class="n">enhancer</span><span class="o">.</span><span class="na">setCallback</span><span class="o">(</span><span class="k">new</span> <span class="nc">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">intercept</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="nc">MethodProxy</span> <span class="n">proxy</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"CGLIB动态代理：目标对象方法执行之前 ..."</span><span class="o">);</span>
                <span class="c1">// 这里看到，CGLIB最终会调用父类，也就是目标类的方法</span>
                <span class="nc">Object</span> <span class="n">returnObj</span> <span class="o">=</span> <span class="n">proxy</span><span class="o">.</span><span class="na">invokeSuper</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"CGLIB动态代理：目标对象方法执行之后 ..."</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">returnObj</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="k">return</span> <span class="n">enhancer</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p>参考：</p>

<ul>
  <li><a href="https://www.zhihu.com/question/20794107/answer/658139129">Java 动态代理作用是什么？</a></li>
  <li><a href="https://www.cnblogs.com/carpenterlee/p/8241042.html">Java Proxy和CGLIB动态代理原理</a></li>
</ul>
</content>
      <pubDate>Thu, 10 Oct 2019 15:36:15 +0000</pubDate>
      <gui>/2019/10/10/java-proxy.html</gui>
    </item>
  
    <item>
      <title>Java ThreadLocalRandom</title>
      <link>/2019/09/28/java-threadlocalrandom.html</link>
      <content><p>在日常开发中，经常会遇到需要生成随机数的情况。一般我都是直接使用<code class="language-plaintext highlighter-rouge">java.util.Random</code>类直接生成，因为Random类是线程安全的，完全可以在多个线程间共享它的实例。我一直都是这样用的，好像并没有觉得有什么不妥。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">RandomUtils</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
    
    <span class="kd">private</span> <span class="nf">RandomUtils</span><span class="o">()</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">nextInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">bound</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">bound</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>直到我看了阿里巴巴的开发手册，才发现我这种用法是不太好的。以下摘自阿里巴巴开发手册：</p>

<blockquote>
  <p>【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed导致的性能下降。 <br />
说明：Random实例包括<code class="language-plaintext highlighter-rouge">java.util.Random</code>的实例或者<code class="language-plaintext highlighter-rouge">Math.random()</code>的方式。 <br />
正例：JDK7之后，可以直接使用 API ThreadLocalRandom；JDK7之前，需要编码保证每个线程持有一个实例。</p>
</blockquote>

<p>好吧，我承认是我太菜了。我之前的用法其实没错，但是在高并发情况下会出现性能问题，属于不推荐的使用方式。</p>

<h3 id="一直接共享random实例的问题">一、直接共享Random实例的问题</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Random</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">AtomicLong</span> <span class="n">seed</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">multiplier</span> <span class="o">=</span> <span class="mh">0x5DEECE66D</span><span class="no">L</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">addend</span> <span class="o">=</span> <span class="mh">0xB</span><span class="no">L</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">mask</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    
    <span class="kd">protected</span> <span class="kt">int</span> <span class="nf">next</span><span class="o">(</span><span class="kt">int</span> <span class="n">bits</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">oldseed</span><span class="o">,</span> <span class="n">nextseed</span><span class="o">;</span>
        <span class="nc">AtomicLong</span> <span class="n">seed</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">seed</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{</span>
            <span class="n">oldseed</span> <span class="o">=</span> <span class="n">seed</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  <span class="c1">// 获取上一次的seed</span>
            <span class="n">nextseed</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldseed</span> <span class="o">*</span> <span class="n">multiplier</span> <span class="o">+</span> <span class="n">addend</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">;</span>  <span class="c1">// 计算新的seed</span>
            <span class="c1">// CAS操作设置新的seed：多线程并发更新seed，失败的线程会自旋重试</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">seed</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">oldseed</span><span class="o">,</span> <span class="n">nextseed</span><span class="o">));</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">nextseed</span> <span class="o">&gt;&gt;&gt;</span> <span class="o">(</span><span class="mi">48</span> <span class="o">-</span> <span class="n">bits</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Random在生成随机数的时候，是根据seed来计算生成的：</p>

<ol>
  <li>先拿到上一次的seed</li>
  <li>然后根据上一次的seed，计算新的seed</li>
  <li>最后使用CAS操作设置新的seed</li>
</ol>

<p>看上面Random的next方法源码，在高并发情况下，CAS操作会成为性能瓶颈。因为会有很多线程更新seed失败而自旋重试，竞争很激烈，导致性能下降。</p>

<p>所以，最好能保证每个线程都有自己的Random实例，避免并发情况下多线程同时竞争更新seed的值导致的性能问题。下面使用ThreadLocal来将Random实例隔离起来，让每个线程都有自己的Random实例。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">RandomUtils</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Random</span><span class="o">&gt;</span> <span class="n">threadLocal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>
    
    <span class="kd">private</span> <span class="nf">RandomUtils</span><span class="o">()</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">nextInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">bound</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getThreadLocalRandom</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="n">bound</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Random</span> <span class="nf">getThreadLocalRandom</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">threadLocal</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">new</span> <span class="nc">Random</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">threadLocal</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="二使用threadlocalrandom">二、使用ThreadLocalRandom</h3>

<p>JDK7以及之后的版本，可以直接使用<code class="language-plaintext highlighter-rouge">java.util.concurrent.ThreadLocalRandom</code>类，它已经帮我们封装好了，使用起来也方便很多，直接在用到随机数的地方使用<code class="language-plaintext highlighter-rouge">ThreadLocalRandom.current().nextInt()</code>即可。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLocalRandomTest</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="kt">int</span> <span class="n">randomInt</span> <span class="o">=</span> <span class="nc">ThreadLocalRandom</span><span class="o">.</span><span class="na">current</span><span class="o">().</span><span class="na">nextInt</span><span class="o">();</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"随机数："</span> <span class="o">+</span> <span class="n">randomInt</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>只需要在使用到随机数的地方通过<code class="language-plaintext highlighter-rouge">ThreadLocalRandom.current()</code>这种方式就可以获取到当前线程的随机数生成器，而不需要共享ThreadLocalRandom的实例。</p>

<p>不要在多线程间共享ThreadLocalRandom的实例，因为这样跟共享Random实例一样会产生并发更新<code class="language-plaintext highlighter-rouge">seed</code>的竞争。</p>

<hr />

</content>
      <pubDate>Sat, 28 Sep 2019 02:10:48 +0000</pubDate>
      <gui>/2019/09/28/java-threadlocalrandom.html</gui>
    </item>
  
    <item>
      <title>Java线程池ThreadPoolExecutor</title>
      <link>/2019/08/24/java-threadpoolexecutor.html</link>
      <content><p>先贴出使用<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>来创建线程池的核心构造函数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span>
                              <span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">,</span>
                              <span class="kt">long</span> <span class="n">keepAliveTime</span><span class="o">,</span>
                              <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">,</span>
                              <span class="nc">BlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">workQueue</span><span class="o">,</span>
                              <span class="nc">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">,</span>
                              <span class="nc">RejectedExecutionHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">...</span> 
<span class="o">}</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: left">参数名称</th>
      <th style="text-align: left">参数说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">corePoolSize</td>
      <td style="text-align: left">线程池的核心线程数，一旦创建就会一直保留在线程池中（除非调用<code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut(true)</code>方法将<code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut</code>参数设置成<code class="language-plaintext highlighter-rouge">true</code>）</td>
    </tr>
    <tr>
      <td style="text-align: left">maximumPoolSize</td>
      <td style="text-align: left">线程池中允许存活的最大线程数</td>
    </tr>
    <tr>
      <td style="text-align: left">keepAliveTime</td>
      <td style="text-align: left">当创建的线程数量超过了核心线程数，允许线程池中处于空闲状态的非核心线程的存活时间（若设置<code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut</code>参数为<code class="language-plaintext highlighter-rouge">true</code>，空闲超时的核心线程也会被回收）</td>
    </tr>
    <tr>
      <td style="text-align: left">unit</td>
      <td style="text-align: left">keepAliveTime参数的时间单位，例如<code class="language-plaintext highlighter-rouge">TimeUnit.MILLISECONDS</code></td>
    </tr>
    <tr>
      <td style="text-align: left">workQueue</td>
      <td style="text-align: left">工作队列（阻塞队列），用于存放将被执行的线程任务（Runnable tasks）</td>
    </tr>
    <tr>
      <td style="text-align: left">threadFactory</td>
      <td style="text-align: left">创建线程的工厂，可以用于标记区分不同线程池所创建出来的线程</td>
    </tr>
    <tr>
      <td style="text-align: left">handler</td>
      <td style="text-align: left">拒绝策略handler。当线程池中线程数量和工作队列的容量均达到上限，继续向线程池提交任务时所触发的拒绝策略逻辑handler</td>
    </tr>
  </tbody>
</table>

<h3 id="1-线程池大小与线程存活时间">1. 线程池大小与线程存活时间</h3>

<p>线程池有两个关于线程数量配置的参数：<code class="language-plaintext highlighter-rouge">corePoolSize</code>和<code class="language-plaintext highlighter-rouge">maximumPoolSize</code>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">corePoolSize</code>：设置线程池的核心线程数</li>
  <li><code class="language-plaintext highlighter-rouge">maximumPoolSize</code>：设置线程池中允许存活的最大线程数</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">keepAliveTime</code>参数用于设置<strong>非核心线程</strong>的存活时间，使用<code class="language-plaintext highlighter-rouge">unit</code>参数指定时间单位。即<strong>非核心线程</strong>空闲的时间超过了所设置的keepAliveTime，线程就会被回收。默认情况下，核心线程一旦被创建就不会被回收，但是若设置了<code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut</code>参数为<code class="language-plaintext highlighter-rouge">true</code>，核心线程也会被回收。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 允许回收空闲的核心线程</span>
<span class="n">threadPoolExecutor</span><span class="o">.</span><span class="na">allowCoreThreadTimeOut</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</code></pre></div></div>

<p>线程池创建后，池中默认不会有任何线程。当向线程池中提交任务时，线程池才会创建线程。但是如果显式调用了prestartAllCoreThreads()或者prestartCoreThread()方法，会立即创建核心线程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 调用prestartAllCoreThreads()来立即创建所有核心线程</span>
<span class="n">threadPoolExecutor</span><span class="o">.</span><span class="na">prestartAllCoreThreads</span><span class="o">();</span>
<span class="c1">// 或者调用prestartCoreThread()来立即创建一个核心线程</span>
<span class="n">threadPoolExecutor</span><span class="o">.</span><span class="na">prestartCoreThread</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="2-线程池工作队列work-queue">2. 线程池工作队列（Work Queue）</h3>

<p>工作队列的用处就是用来缓存所提交的线程任务（Runnable task）。线程池的工作队列采用的是阻塞队列（BlockingQueue），可以直接在多线程并发的环境下缓存线程任务。</p>

<blockquote>
  <p>阻塞队列特性：如果阻塞队列为空（empty），则尝试从队列中获取（读取）任务的线程会被阻塞；如果阻塞队列满了（full），则尝试往队列中插入任务的线程会被阻塞。</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: left">阻塞队列</th>
      <th style="text-align: left">阻塞队列说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ArrayBlockingQueue</td>
      <td style="text-align: left">一个基于数组结构的<strong>有界</strong>阻塞队列。</td>
    </tr>
    <tr>
      <td style="text-align: left">LinkedBlockingQueue</td>
      <td style="text-align: left">一个基于链表结构的<strong>有界</strong>阻塞队列。</td>
    </tr>
    <tr>
      <td style="text-align: left">SynchronousQueue</td>
      <td style="text-align: left">同步移交队列，本身不存储任何元素。一个线程的插入操作必须等待另一个线程来读取才能完成，才会允许下一个插入操作。</td>
    </tr>
    <tr>
      <td style="text-align: left">PriorityBlockingQueue</td>
      <td style="text-align: left">一个支持优先级排序的<strong>无界</strong>阻塞队列。</td>
    </tr>
    <tr>
      <td style="text-align: left">DelayQueue</td>
      <td style="text-align: left">一个使用优先级队列实现的<strong>无界</strong>阻塞队列。用于处理延迟任务。</td>
    </tr>
  </tbody>
</table>

<h3 id="3-线程池拒绝策略rejected-handler">3. 线程池拒绝策略（Rejected Handler）</h3>

<p>当线程池的工作队列满了，并且线程池中线程数量也已经达到最大值；继续往线程池中提交任务时，就会触发拒绝策略。<code class="language-plaintext highlighter-rouge">  ThreadPoolExecutor</code>内置了四种拒绝策略：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AbortPolicy</code>：取消策略，丢弃任务并抛出RejectedExecutionException，默认的拒绝策略。</li>
  <li><code class="language-plaintext highlighter-rouge">DiscardPolicy</code>：丢弃策略，丢弃任务但是不会抛出任何异常。</li>
  <li><code class="language-plaintext highlighter-rouge">DiscardOldestPolicy</code>：丢弃策略，丢弃队列中最老的任务并尝试重新执行所提交的任务。</li>
  <li><code class="language-plaintext highlighter-rouge">CallerRunsPolicy</code>：调用者执行策略，将任务直接给提交该任务的线程来执行。</li>
</ul>

<p>以上四种拒绝策略是<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>内置的，对于被拒绝的任务处理比较简单。我们也可以继承这些拒绝策略类或者直接实现<code class="language-plaintext highlighter-rouge">RejectedExecutionHandler</code>接口来自定义拒绝策略。</p>

<h3 id="4-线程池工作流程要点">4. 线程池工作流程要点</h3>

<ol>
  <li>当线程池中的线程数量<strong>小于</strong>核心线程数：新提交一个任务时，无论是否存在空闲的线程，线程池都将新建一个新的线程来执行新任务；</li>
  <li>当线程池中的线程数量<strong>等于</strong>核心线程数（核心线程已满）：新提交的任务会被存储到工作队列中，等待空闲线程来执行，<strong>而不会创建新线程</strong>；</li>
  <li>当工作队列已满，并且池中的线程数量<strong>小于</strong>最大线程数（<code class="language-plaintext highlighter-rouge">maximumPoolSize</code>）：如果继续提交新的任务，线程池会创建新线程来处理任务；</li>
  <li>当工作队列已满，并且池中线程数量已达到最大值：继续提交新任务时，线程池会触发拒绝策略处理逻辑；</li>
  <li>如果线程池中存在空闲的线程并且其空闲时间达到了<code class="language-plaintext highlighter-rouge">keepAliveTime</code>参数的限定值，线程池会回收这些空闲线程，但是线程池不会回收空闲的核心线程；但是如果在创建线程池的时候设置了<code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut</code>参数为<code class="language-plaintext highlighter-rouge">true</code>，空闲超时的核心线程也会被回收。</li>
</ol>

<h3 id="5-如何向线程池提交任务">5. 如何向线程池提交任务？</h3>

<p>向线程池中提交线程任务有两种方式：调用<code class="language-plaintext highlighter-rouge">execute</code>方法或者调用<code class="language-plaintext highlighter-rouge">submit</code>方法。</p>

<h5 id="51-调用execute方法提交任务">5.1 调用<code class="language-plaintext highlighter-rouge">execute</code>方法提交任务</h5>

<p>execute方法定义在<code class="language-plaintext highlighter-rouge">java.util.concurrent.Executor</code>接口中：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Executor</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>execute方法没有返回值，并且只能接收<code class="language-plaintext highlighter-rouge">Runnable</code>类型的任务，总体来说比较简单，任务提交之后就是等待CPU调度执行了。</p>

<h5 id="52-调用submit方法提交任务">5.2 调用<code class="language-plaintext highlighter-rouge">submit</code>方法提交任务</h5>

<p>submit方法定义在<code class="language-plaintext highlighter-rouge">java.util.concurrent.ExecutorService</code>接口中，有三种形式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ExecutorService</span> <span class="kd">extends</span> <span class="nc">Executor</span> <span class="o">{</span>
    <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="o">);</span>
    <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="no">T</span> <span class="n">result</span><span class="o">);</span>
    <span class="nc">Future</span><span class="o">&lt;?&gt;</span> <span class="n">submit</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">task</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>与execute方法不同的是，submit方法有返回值，这就意味着我们可以在线程任务执行完之后，拿到线程任务执行结果；而且除了<code class="language-plaintext highlighter-rouge">Runnable</code>任务，submit还支持提交<code class="language-plaintext highlighter-rouge">Callable</code>类型的任务，我们来看看<code class="language-plaintext highlighter-rouge">Callable</code>是什么：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">V</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>很明显，跟<code class="language-plaintext highlighter-rouge">Runnable</code>一样也是个函数式接口（FunctionalInterface），但是跟<code class="language-plaintext highlighter-rouge">Runnable</code>不一样的地方在于，<code class="language-plaintext highlighter-rouge">Callable</code>带有返回值！这就为我们在任务执行完毕之后获取执行结果提供了可能！</p>

<p>下面来看看submit的第一个方法：<code class="language-plaintext highlighter-rouge">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</code></p>

<p><img src="/static/image/2020-06/submit1.png" alt="submit1.png" /></p>

<p>submit的其他两个方法也差不多类似，这里就不详细展开了。它们虽然接收的是<code class="language-plaintext highlighter-rouge">Runnable</code>类型参数，但是最终都会转换成<code class="language-plaintext highlighter-rouge">Callable</code>类型任务：</p>

<p><img src="/static/image/2020-06/runnable2callable.png" alt="runnable2callable.png" /></p>

<p>总之，submit方法将提交的<code class="language-plaintext highlighter-rouge">Runnable</code>或<code class="language-plaintext highlighter-rouge">Callable</code>任务封装成一个<code class="language-plaintext highlighter-rouge">FutureTask</code>对象，最终执行任务的时候，就是调用<code class="language-plaintext highlighter-rouge">FutureTask</code>对象中的<code class="language-plaintext highlighter-rouge">run</code>方法：</p>

<p><img src="/static/image/2020-06/futuretask-run.png" alt="futuretask-run.png" /></p>

<p>submit提交任务后，若任务执行时发生异常，异常不会直接抛出来，而是会被FutureTask封装到一个名叫<code class="language-plaintext highlighter-rouge">outcome</code>变量中，等到调用<code class="language-plaintext highlighter-rouge">Future.get</code>的时候异常才会抛出来，这点在使用的时候要注意。</p>

<p><img src="/static/image/2020-06/future-get.png" alt="future-get.png" /></p>

<p>submit在线程任务异常的处理方式上与execute区别很大：execute的异常只能由线程池中执行该任务的线程自己消化掉，例如<code class="language-plaintext highlighter-rouge">try-catch</code>掉，在其他地方（例如调用者线程）企图<code class="language-plaintext highlighter-rouge">try-catch</code>任务的异常，是没法做到的。对于execute方式，想要在其他地方捕获任务执行时抛出的异常，似乎只能通过为线程设置<code class="language-plaintext highlighter-rouge">Thread.UncaughtExceptionHandler</code>来完成。</p>

<p>submit则是先将异常封装起来，不会立即抛出。直到调用<code class="language-plaintext highlighter-rouge">Future.get</code>的时候才会将异常抛出，即我们能从其他地方捕获到任务的异常。在使用的时候需要注意，因为有时候只是想向线程池中提交任务，而不会调用<code class="language-plaintext highlighter-rouge">Future.get</code>获取结果（因为不关心结果）。如果发生异常，FutureTask会「吞掉」我们的异常，我们在日志中根本看不到任何异常信息，这会对我们的问题排查带来很大问题。</p>

<h5 id="53-选择execute还是submit">5.3 选择execute还是submit？</h5>

<p>通常情况下，如果如果不关心任务执行结果，那么直接用execute方法即可；如果关心结果，可以使用<code class="language-plaintext highlighter-rouge">submit + Future.get</code>组合来拿到任务执行结果。</p>

<p>另外，execute和submit方法对异常的处理方式也不同，execute提交的任务在执行时如果发生异常，会被执行该任务的线程消化掉（要么线程自己<code class="language-plaintext highlighter-rouge">try-catch</code>掉，要么线程没处理，线程终止），外部其他地方无法捕获，除非设置了<code class="language-plaintext highlighter-rouge">Thread.UncaughtExceptionHandler</code>；submit方法提交的任务在执行时发生的异常，会被FutureTask「吞掉」，然后在用户调用<code class="language-plaintext highlighter-rouge">Future.get</code>时将异常抛出。</p>

<h3 id="6-线程池工具类executors">6. 线程池工具类（Executors）</h3>

<p>JDK提供了<code class="language-plaintext highlighter-rouge">java.util.concurrent.Executors</code>这个工具类来帮助我们快速创建线程池。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">newFixedThreadPool(int nThreads)</code>：创建一个固定数量线程的线程池，池中的线程数量达到最大值后会始终保持不变。</li>
  <li><code class="language-plaintext highlighter-rouge">newSingleThreadExecutor()</code>：创建一个只包含单个线程的线程池，可以保证所有任务按提交的顺序被单一的一个线程串行地执行。</li>
  <li><code class="language-plaintext highlighter-rouge">newCachedThreadPool()</code>：创建一个会根据任务按需地创建、回收线程的线程池。这种类型线程池适合执行数量多、耗时少的任务。</li>
  <li><code class="language-plaintext highlighter-rouge">newScheduledThreadPool(int corePoolSize)</code>：创建一个具有定时功能的线程池，适用于执行定时任务。</li>
</ul>

<p>以上四种定义好的线程池确实很方便我们的使用，但是我们需要了解它们的隐患之处：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FixedThreadPool</code>、<code class="language-plaintext highlighter-rouge">SingleThreadPool</code>的工作队列最大容量为<code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>，这有可能会随着工作队列中的任务堆积而导致<code class="language-plaintext highlighter-rouge">OOM</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">CachedThreadPool</code>、<code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code>允许最大线程数为<code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>，这也有可能因为创建大量线程导致<code class="language-plaintext highlighter-rouge">OOM</code>或者线程切换开销巨大。</li>
</ul>

<hr />

</content>
      <pubDate>Sat, 24 Aug 2019 04:41:45 +0000</pubDate>
      <gui>/2019/08/24/java-threadpoolexecutor.html</gui>
    </item>
  
    <item>
      <title>Java线程间通信之wait/notify</title>
      <link>/2019/08/24/java-how-to-use-wait-notify.html</link>
      <content><blockquote>
  <p>此文为自己翻译的文章，在保留原意的基础上对原文的代码稍有调整。<br /> 英文原文地址：<a href="https://javarevisited.blogspot.com/2015/07/how-to-use-wait-notify-and-notifyall-in.html">How to use wait, notify and notifyAll in Java - Producer Consumer Example</a>。</p>
</blockquote>

<p>在Java中，可以使用wait，notify和notifyAll方法来实现线程间的通信。</p>

<p>举个栗子，程序中运行着两个线程，分别是<strong>生产者线程</strong>和<strong>消费者线程</strong>。假设有一个固定容量的消息队列：当队列中有可消费的消息时，生产者线程会通知消费者线程进行消息的消费；同样地，当队列中有额外的空间时，消费者线程会通知生产者线程进行消息的生产。即：当消息队列满了，生产者线程应该停止生产并进入等待状态；当消息队列为空的时候，消费者线程应该停止消费并进入等待状态。</p>

<p>如果某些线程正在等待某些条件变为<code class="language-plaintext highlighter-rouge">true</code>，你可以在条件改变的时候使用notify或者notifyAll方法来通知这些线程并唤醒它们。notify方法和notifyAll方法都会向等待的线程发送通知，区别在于：如果有多个线程处于等待状态，notify发送的通知只会被其中一个线程收到，且不能保证是哪个线程收到；而notifyAll发送的通知会被所有线程收到。如果只有一个线程在等待<strong>对象锁</strong>，那么notify和notifyAll的效果是一样的，发出的通知都会被该线程接收到。</p>

<blockquote>
  <p>在这篇文章中，你将会学习到如何使用wait，notify和notifyAll方法实现线程间通信，并解决生产者-消费者的问题。如果你真正想掌握并发和多线程，我强烈建议你读一读《Java Concurrency In Practice》这本书，作者是Brian Goetz。没读过此书，你对Java多线程的理解是不完整的。</p>
</blockquote>

<h2 id="1-如何在代码中使用wait和notify方法">1. 如何在代码中使用wait和notify方法</h2>
<p>wait和notify都是定义在java.lang.Object类中的方法。虽然它们都是很基础的概念，但是想在实际代码中使用它们却不是那么容易呢。不信你可以在面试中让面试者使用wait和notify徒手撸代码来解决<strong>生产者-消费者问题</strong>？我相信很多人会一脸的疑惑。
很多人都会对这个问题不知所措或者错误地使用wait和notify，例如代码块使用同步的地方错了、没有用正确的对象来调用wait方法。老实说，这些困扰着很多程序员。</p>

<blockquote>
  <p>困惑1：如何使用wait方法？wait方法不是java.lang.Thread类中定义的，所以你不能直接向调用Thread.sleep()那样来调用wait方法。<br /></p>
</blockquote>

<p><a>正确调用wait方法的姿势：<strong>你有一个被多个线程共享的对象实例，你需要使用该对象实例来调用wait方法！</strong> 在生产者-消费者问题里面，这个被共享的对象实例就是指被生产者和消费者共享的队列。</a></p>

<blockquote>
  <p>困惑2：应该在同步代码块（synchronized block）中调wait方法还是在同步的方法（synchronized method）中调用wait方法？如果使用同步块，哪个对象应该被放在同步块中？</p>
</blockquote>

<p><a>答案是：加锁的对象和你要获取锁的对象应该是同一个！在这个例子中，就是那个队列的对象实例。</a></p>

<h2 id="2-在循环体中调用wait方法而非if代码块中">2. 在循环体中调用wait方法，而非if代码块中</h2>
<p>你现在已经知道需要使用一个同步的、共享的对象来调用wait方法，接下来要做的就是在<code class="language-plaintext highlighter-rouge">while</code>循环中调用wait方法，而不是在<code class="language-plaintext highlighter-rouge">if</code>代码块中调用。
我们需要在某些条件成立的情况下调用wait方法，例如生产者线程应该在队列满的时候调用wait。这时候我们首先会想到使用<code class="language-plaintext highlighter-rouge">if</code>来判断条件是否成立。但是在<code class="language-plaintext highlighter-rouge">if</code>代码块中调用wait方法可能会产生BUG，因为线程有可能会在等待条件未改变的情况下被<strong>虚假唤醒（spurious wakeup）</strong>。如果没有使用循环来在线程唤醒后检查等待条件，就很可能会造成错误。例如会造成往满队列中写数据或者从空队列中取数据。这就是我们应该在循环体中调用wait，而不是在<code class="language-plaintext highlighter-rouge">if</code>块中调用wait的原因。
另外，我也推荐阅读《Effective Java》这本书里面关于这部分内容的描述，也许是wait和notify使用的最佳实践。
基于上述知识，这里给出在Java中调用wait和notify的标准方式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在Java中调用wait方法的正确姿势</span>
<span class="kd">synchronized</span> <span class="o">(</span><span class="n">sharedObject</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">while</span> <span class="o">(</span><span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">sharedObject</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span> <span class="c1">// 在循环体中调用wait方法：线程会释放对象锁，等待被唤醒</span>
   <span class="o">}</span>
   <span class="c1">// 在这里执行一些操作：例如将消息写入队列或者从队列中获取消息</span>
<span class="o">}</span>
</code></pre></div></div>

<p>正如我所说的那样，始终应该在循环体中调用wait。这个循环体是用来对线程<strong>进入等待</strong>和<strong>被唤醒后</strong>的条件进行检测。<strong>如果条件成立，并且notify或notifyAll方法在线程执行wait方法之前被调用了，线程就有可能一直wait，导致死锁。</strong></p>

<h2 id="3-正确使用waitnotify和notifyall的例子">3. 正确使用wait，notify和notifyAll的例子</h2>
<blockquote>
  <p>这个例子将演示如何使用我们上面讨论的标准方法来使用wait，notify和notifyAll方法。
在这个例子中，我们有两个线程：生产者线程和消费者线程，分别由Producer和Consumer两个类来表示。我们使用LinkedList对象实例作为共享的消息队列。</p>
</blockquote>

<p>生产者运行在一个死循环中，并不断生产消息、将消息写入队列。通过<code class="language-plaintext highlighter-rouge">while(queue.size &gt;= maxSize)</code>条件来判断队列是否已满。<strong>记住：在执行<code class="language-plaintext highlighter-rouge">while(queue.size == maxSize)</code>条件检查之前，先给队列的对象实例加锁，保证我们执行检查时不会有其他线程修改队列。</strong> 如果队列满了，生产者线程会调用wait挂起，直到消费者消费了消息并调用notify通知生产者继续消费。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 生产者线程</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Producer</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">Producer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">maxSize</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">messageCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Producer</span><span class="o">(</span><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxSize</span><span class="o">,</span> <span class="nc">String</span> <span class="n">threadName</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">threadName</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">maxSize</span> <span class="o">=</span> <span class="n">maxSize</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 在条件判断之前给共享资源加锁</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">maxSize</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"消息队列已满: 生产者线程调用wait方法进入等待状态 ..."</span><span class="o">);</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span> <span class="c1">// 在循环体中：使用共享对象来调用wait方法，释放共享资源的锁</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
               
                <span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>  <span class="c1">// 让生产者每1秒钟生产一条消息</span>
              
                <span class="kt">int</span> <span class="n">messageId</span> <span class="o">=</span> <span class="n">messageCount</span><span class="o">++;</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"生产消息: {}"</span><span class="o">,</span> <span class="n">messageId</span><span class="o">);</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">messageId</span><span class="o">);</span>  <span class="c1">// 将消息写入队列</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>     <span class="c1">// 通知消费者线程，对消息进行消费</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// 消费者线程</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Consumer</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Consumer</span><span class="o">(</span><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">,</span> <span class="nc">String</span> <span class="n">threadName</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">threadName</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 在条件判断之前给共享资源加锁</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"消息队列为空: 消费者线程调用wait方法进入等待状态 ..."</span><span class="o">);</span>
                        <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>  <span class="c1">// 在循环体中：使用共享对象来调用wait方法，释放共享资源的锁</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"消费消息: {}"</span><span class="o">,</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>     <span class="c1">// 通知生产者线程，可以继续生产消息了</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 测试代码</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Launcher</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">maxSize</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="k">new</span> <span class="nf">Producer</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="n">maxSize</span><span class="o">,</span> <span class="s">"producer-thread"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Consumer</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="s">"consumer-thread"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
    
<span class="o">}</span>
</code></pre></div></div>
<p>执行的结果如下日志所示：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2019-08-24 14:59:46.149 INFO  <span class="o">[</span>producer-thread] 生产消息: 1
2019-08-24 14:59:47.166 INFO  <span class="o">[</span>producer-thread] 生产消息: 2
2019-08-24 14:59:48.167 INFO  <span class="o">[</span>producer-thread] 生产消息: 3
2019-08-24 14:59:48.167 INFO  <span class="o">[</span>consumer-thread] 消费消息: 1
2019-08-24 14:59:48.167 INFO  <span class="o">[</span>consumer-thread] 消费消息: 2
2019-08-24 14:59:48.167 INFO  <span class="o">[</span>consumer-thread] 消费消息: 3
2019-08-24 14:59:48.167 INFO  <span class="o">[</span>consumer-thread] 消息队列为空: 消费者线程调用wait方法进入等待状态 ...
2019-08-24 14:59:49.167 INFO  <span class="o">[</span>producer-thread] 生产消息: 4
2019-08-24 14:59:50.168 INFO  <span class="o">[</span>producer-thread] 生产消息: 5
2019-08-24 14:59:51.168 INFO  <span class="o">[</span>producer-thread] 生产消息: 6
2019-08-24 14:59:52.169 INFO  <span class="o">[</span>producer-thread] 生产消息: 7
2019-08-24 14:59:53.170 INFO  <span class="o">[</span>producer-thread] 生产消息: 8
2019-08-24 14:59:53.170 INFO  <span class="o">[</span>producer-thread] 消息队列已满: 生产者线程调用wait方法进入等待状态 ...
2019-08-24 14:59:53.170 INFO  <span class="o">[</span>consumer-thread] 消费消息: 4
2019-08-24 14:59:53.170 INFO  <span class="o">[</span>consumer-thread] 消费消息: 5
2019-08-24 14:59:53.170 INFO  <span class="o">[</span>consumer-thread] 消费消息: 6
2019-08-24 14:59:53.170 INFO  <span class="o">[</span>consumer-thread] 消费消息: 7
2019-08-24 14:59:53.170 INFO  <span class="o">[</span>consumer-thread] 消费消息: 8
2019-08-24 14:59:53.170 INFO  <span class="o">[</span>consumer-thread] 消息队列为空: 消费者线程调用wait方法进入等待状态 ...
2019-08-24 14:59:54.170 INFO  <span class="o">[</span>producer-thread] 生产消息: 9
2019-08-24 14:59:54.170 INFO  <span class="o">[</span>consumer-thread] 消费消息: 9
2019-08-24 14:59:54.170 INFO  <span class="o">[</span>consumer-thread] 消息队列为空: 消费者线程调用wait方法进入等待状态 ...
2019-08-24 14:59:55.171 INFO  <span class="o">[</span>producer-thread] 生产消息: 10
2019-08-24 14:59:56.171 INFO  <span class="o">[</span>producer-thread] 生产消息: 11
2019-08-24 14:59:57.172 INFO  <span class="o">[</span>producer-thread] 生产消息: 12
2019-08-24 14:59:58.172 INFO  <span class="o">[</span>producer-thread] 生产消息: 13
2019-08-24 14:59:59.173 INFO  <span class="o">[</span>producer-thread] 生产消息: 14
2019-08-24 14:59:59.173 INFO  <span class="o">[</span>producer-thread] 消息队列已满: 生产者线程调用wait方法进入等待状态 ...
2019-08-24 14:59:59.173 INFO  <span class="o">[</span>consumer-thread] 消费消息: 10
2019-08-24 14:59:59.173 INFO  <span class="o">[</span>consumer-thread] 消费消息: 11
2019-08-24 14:59:59.173 INFO  <span class="o">[</span>consumer-thread] 消费消息: 12
2019-08-24 14:59:59.173 INFO  <span class="o">[</span>consumer-thread] 消费消息: 13
2019-08-24 14:59:59.173 INFO  <span class="o">[</span>consumer-thread] 消费消息: 14
2019-08-24 14:59:59.173 INFO  <span class="o">[</span>consumer-thread] 消息队列为空: 消费者线程调用wait方法进入等待状态 ...
2019-08-24 15:00:00.174 INFO  <span class="o">[</span>producer-thread] 生产消息: 15
2019-08-24 15:00:01.174 INFO  <span class="o">[</span>producer-thread] 生产消息: 16
2019-08-24 15:00:02.175 INFO  <span class="o">[</span>producer-thread] 生产消息: 17
2019-08-24 15:00:03.175 INFO  <span class="o">[</span>producer-thread] 生产消息: 18
2019-08-24 15:00:04.175 INFO  <span class="o">[</span>producer-thread] 生产消息: 19
2019-08-24 15:00:04.175 INFO  <span class="o">[</span>producer-thread] 消息队列已满: 生产者线程调用wait方法进入等待状态 ...
</code></pre></div></div>
<h2 id="4-写在最后">4. 写在最后</h2>
<ul>
  <li>你可以使用wait和notify方法来实现Java的线程间通信。不仅一个或两个线程可以这样做，多线程之间同样可以使用这种方法达到线程间通信的目的。</li>
  <li>要在同步方法或者同步块中调用wait，notify和notifyAll方法，否则JVM会抛IllegalMonitorStateException。</li>
  <li>要在循环体中调用wait和notify方法，不要在<code class="language-plaintext highlighter-rouge">if</code>块中调用。因为循环可以做到在wait前后对条件进行检测。</li>
  <li>使用共享对象来调用wait方法。</li>
  <li>最好使用notifyAll而不是notify，原因在<a href="https://javarevisited.blogspot.com/2012/10/difference-between-notify-and-notifyall-java-example.html">这里</a>。</li>
</ul>

<hr />

</content>
      <pubDate>Sat, 24 Aug 2019 03:18:10 +0000</pubDate>
      <gui>/2019/08/24/java-how-to-use-wait-notify.html</gui>
    </item>
  
    <item>
      <title>Jekyll博客搭建</title>
      <link>/2019/08/20/build-jekyll-blog.html</link>
      <content><p>博客基于 <a href="https://jekyllrb.com" target="_blank">Jekyll</a> 博客框架来搭建，并采用 <a href="https://github.com/loji44/ExSimple" target="_blank">ExSimple</a> 作为博客主题。分两步走：</p>

<ul>
  <li>安装Jekyll博客的开发环境</li>
  <li>配置ExSimple作为博客主题</li>
</ul>

<h3 id="一安装jekyll博客开发环境">一、安装Jekyll博客开发环境</h3>
<p>Jekyll依赖Ruby语言环境，所以要先安装Ruby。我自己电脑(MacOS)本身自带了Ruby，版本为：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ruby <span class="nt">-v</span>
ruby 2.3.7p456 <span class="o">(</span>2018-03-28 revision 63024<span class="o">)</span> <span class="o">[</span>universal.x86_64-darwin18]
</code></pre></div></div>

<p>首先，执行下面的指令来安装 Jekyll：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gem <span class="nb">install </span>bundler jekyll
</code></pre></div></div>

<p>很遗憾，我运行该指令到最后，它报了一个错误给我：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>··· ···
Fetching: jekyll-sass-converter-2.0.0.gem <span class="o">(</span>100%<span class="o">)</span>
ERROR:  Error installing jekyll:
	jekyll-sass-converter requires Ruby version <span class="o">&gt;=</span> 2.4.0.
</code></pre></div></div>

<p>嗯… 很明显，我电脑自带的Ruby版本没满足Jekyll要求的版本。还能怎么办？那就来升级一下Ruby的版本呗 <code class="language-plaintext highlighter-rouge">:)</code></p>

<p>这里通过Ruby的版本管理器<a href="http://rvm.io" target="_blank">RVM</a>(<code class="language-plaintext highlighter-rouge">Ruby Version Manager</code>)来升级Ruby的版本。先来安装RVM：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-L</span> get.rvm.io | bash <span class="nt">-s</span> stable
</code></pre></div></div>

<p>RVM安装完成之后，执行下面的指令来使RVM立即生效：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">source</span> ~/.rvm/scripts/rvm
</code></pre></div></div>

<p>来检查一下RVM是否已经成功安装以及生效：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rvm <span class="nt">-v</span>
rvm 1.29.9 <span class="o">(</span>latest<span class="o">)</span> by Michal Papis, Piotr Kuczynski, Wayne E. Seguin <span class="o">[</span>https://rvm.io]
</code></pre></div></div>

<p>好了，RVM安装完毕。我们来升级Ruby的版本，从Ruby官网了解到当前最新版本是<code class="language-plaintext highlighter-rouge">2.6.3</code>：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rvm <span class="nb">install </span>2.6.3
... ...
ruby-2.6.3 - <span class="c">#generating default wrappers.......</span>
ruby-2.6.3 - <span class="c">#adjusting #shebangs for (gem irb erb ri rdoc testrb rake).</span>
Install of ruby-2.6.3 - <span class="c">#complete</span>
</code></pre></div></div>

<p>看上面的提示，应该是成功安装了<code class="language-plaintext highlighter-rouge">2.6.3</code>版本的Ruby，我们来检验一下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ruby <span class="nt">-v</span>
ruby 2.6.3p62 <span class="o">(</span>2019-04-16 revision 67580<span class="o">)</span> <span class="o">[</span>x86_64-darwin18]
</code></pre></div></div>

<p>没错了，接下来继续安装我们的Jekyll。直接执行下面的指令进行安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gem <span class="nb">install </span>bundler jekyll
</code></pre></div></div>

<p>这个安装过程可能会有点耗时，请耐心等待安装Jekyll完成 …</p>

<h3 id="二配置exsimple作为博客主题">二、配置ExSimple作为博客主题</h3>

<p>至此，Jekyll开发环境搭建好了。现在来配置ExSimple作为博客主题。</p>

<ul>
  <li>下载ExSimple主题源码</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/loji44/ExSimple.git your_blog
<span class="nv">$ </span><span class="nb">cd </span>your_blog
</code></pre></div></div>

<p>下载之后，直接在<code class="language-plaintext highlighter-rouge">_posts</code>目录下面创建自己的博客文章：<code class="language-plaintext highlighter-rouge">vim 2019-08-20-my-blog.markdown</code> 编辑内容如下</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">---</span>
layout: post
title: 关于我的博客网站
<span class="nb">date</span>: 2019-08-20 15:28:34.000000000 +08:00
tags: 
 - 博客
 - Jekyll
<span class="nt">---</span>

这是我的个人博客。

</code></pre></div></div>

<ul>
  <li>本地调试：启动Jekyll</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bundle <span class="nb">install</span> <span class="o">&amp;&amp;</span> bundle <span class="nb">exec </span>jekyll serve
</code></pre></div></div>

<p>启动成功之后，访问 <a href="http://127.0.0.1:4000" target="_blank">http://127.0.0.1:4000</a> 就可以看到搭建好的博客页面。</p>

<p>Jekyll默认监听的host是<code class="language-plaintext highlighter-rouge">127.0.0.0</code>，只能从本机电脑访问；启动Jekyll的时候使用<code class="language-plaintext highlighter-rouge">--host</code>参数让Jekyll监听的host为<code class="language-plaintext highlighter-rouge">0.0.0.0</code>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bundle <span class="nb">exec </span>jekyll serve <span class="nt">--host</span> 0.0.0.0
Configuration file: /root/your_blog/_config.yml
            Source: /root/your_blog
       Destination: /root/your_blog/_site
 Incremental build: disabled. Enable with <span class="nt">--incremental</span>
      Generating...
                    <span class="k">done in </span>0.408 seconds.
 Auto-regeneration: enabled <span class="k">for</span> <span class="s1">'/root/your_blog'</span>
    Server address: http://0.0.0.0:4000
  Server running... press ctrl-c to stop.
</code></pre></div></div>

<p>还可以使用<code class="language-plaintext highlighter-rouge">--port</code>参数来修改Jekyll监听的端口：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bundle <span class="nb">exec </span>jekyll serve <span class="nt">--host</span> 0.0.0.0 <span class="nt">--port</span> 8080
Configuration file: /root/your_blog/_config.yml
            Source: /root/your_blog
       Destination: /root/your_blog/_site
 Incremental build: disabled. Enable with <span class="nt">--incremental</span>
      Generating...
                    <span class="k">done in </span>0.419 seconds.
 Auto-regeneration: enabled <span class="k">for</span> <span class="s1">'/root/your_blog'</span>
    Server address: http://0.0.0.0:8080
  Server running... press ctrl-c to stop.
</code></pre></div></div>

<p>使用<code class="language-plaintext highlighter-rouge">jekyll serve -h</code>来查看Jekyll启动服务时支持的其他启动参数。</p>

<h3 id="三将jekyll博客以静态资源方式部署">三、将Jekyll博客以静态资源方式部署</h3>

<p>博客文章写完，想将博客打包成静态资源部署到Web服务器上，例如使用<code class="language-plaintext highlighter-rouge">Nginx</code>或者<code class="language-plaintext highlighter-rouge">Github Pages</code>进行部署。</p>

<ul>
  <li>进入博客代码根目录执行下面的指令，将博客打包成静态资源：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bundle <span class="nb">install</span> <span class="o">&amp;&amp;</span> jekyll build
</code></pre></div></div>

<p>运行完毕后，会在根目录下生成<code class="language-plaintext highlighter-rouge">_site</code>文件夹，这个文件夹就是我们的博客文章静态资源。直接将这个文件夹下的全部内容拷贝到<code class="language-plaintext highlighter-rouge">Nginx</code>的静态资源部署目录下，即可完成部署。</p>

<p>或者你使用的是<code class="language-plaintext highlighter-rouge">Github Pages</code>，请移步Github官网教程：<a href="https://pages.github.com" target="_blank">Github Pages</a>。</p>

<hr />

</content>
      <pubDate>Tue, 20 Aug 2019 07:28:34 +0000</pubDate>
      <gui>/2019/08/20/build-jekyll-blog.html</gui>
    </item>
  
    <item>
      <title>Java为什么要覆写equals和hashCode方法？</title>
      <link>/2018/08/26/java-equals-hashcode.html</link>
      <content><p><code class="language-plaintext highlighter-rouge">equals</code> 和 <code class="language-plaintext highlighter-rouge">hashCode</code> 是 <code class="language-plaintext highlighter-rouge">java.lang.Object</code> 类中定义的两个方法，这两个方法均用在对象比较的场景，即判断两个对象是否相等。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Object</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">equals</code>方法的作用是判断所传入的对象是否跟当前对象相同，JDK对这个方法的默认实现就是比较两个对象的内存地址，只有这两个对象的内存地址一样才认为它们相同。</li>
  <li><code class="language-plaintext highlighter-rouge">hashCode</code>方法的作用是为对象生成一个int类型的哈希码（hashcode），其主要用于配合Java中基于散列的集合一起工作，比如HashMap、HashTable以及HashSet。</li>
</ul>

<h3 id="1-覆写equals和hashcode方法">1. 覆写equals和hashCode方法</h3>

<p>要自定义对象的对比逻辑，我们需要覆写对象的equals方法。<strong>如果覆写了equals方法，那么必须同时覆写hashCode方法。因为如果仅仅覆写equals，对象的对比机制可能在某些业务场景能正常工作，但是在结合散列集合（如HashMap）工作的时候，将不能正确按照我们的预期工作！</strong></p>

<blockquote>
  <ol>
    <li>两个对象相等，那它们的<code class="language-plaintext highlighter-rouge">hashCode</code>方法的返回值一定相同</li>
    <li>两个对象的<code class="language-plaintext highlighter-rouge">hashCode</code>方法的返回值相同，这两个对象却不一定相等</li>
  </ol>
</blockquote>

<p>定义一个Book类，我们自定义的对比机制为：当且仅当两本书的id和name都一样的时候，我们认为它们一样（相等，是同一本书）；否则不一样（不是同一本书）。</p>

<p><em>不覆写equals和hashCode的情况：</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Book</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// getter/setter</span>

<span class="o">}</span>
</code></pre></div></div>

<p><em>测试代码1如下所示：</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Book</span> <span class="n">book1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"Effective Java"</span><span class="o">);</span>
    <span class="nc">Book</span> <span class="n">book2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"Effective Java"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"book1.equals(book2): "</span> <span class="o">+</span> <span class="n">book1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">book2</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"book1.hashCode(): "</span> <span class="o">+</span> <span class="n">book1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"book2.hashCode(): "</span> <span class="o">+</span> <span class="n">book2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
<span class="o">}</span>

<span class="c1">// 测试结果</span>
<span class="n">book1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">book2</span><span class="o">):</span> <span class="kc">false</span>
<span class="n">book1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">():</span> <span class="mi">1590550415</span>
<span class="n">book2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">():</span> <span class="mi">1058025095</span>
</code></pre></div></div>

<p>根据场景预设，只要id和name相同我们就认为是同一本书，所以equals对比的结果为<code class="language-plaintext highlighter-rouge">true</code>才符合我们的预期。但是结果并相同，这是因为我们并没有覆写equals方法，所以默认是对比两个对象的地址。上述测试代码分别<code class="language-plaintext highlighter-rouge">new</code>了两个Book对象，地址肯定不一样，所以对比结果为<code class="language-plaintext highlighter-rouge">false</code>。</p>

<p><em>仅覆写equals的情况：现在我们在Book类中覆写equals方法，自定义对比机制</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Book</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">==</span> <span class="o">((</span><span class="nc">Book</span><span class="o">)</span> <span class="n">obj</span><span class="o">).</span><span class="na">getId</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(((</span><span class="nc">Book</span><span class="o">)</span> <span class="n">obj</span><span class="o">).</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>此时再运行test1()测试代码，结果如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">book1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">book2</span><span class="o">):</span> <span class="kc">true</span>
<span class="n">book1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">():</span> <span class="mi">1590550415</span>
<span class="n">book2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">():</span> <span class="mi">1058025095</span>
</code></pre></div></div>

<p>测试结果表明，只要书本的id和name相同，我们自定义的对比机制已经能正确判断它们是同一本书。</p>

<p><em>但是注意：由于我们仅覆写了equals，并没有覆写hashCode，所以比较机制在配合HashMap、HashTable以及HashSet这些散列集合进行使用的时候，将不能正确得到预期的结果。</em></p>

<p>测试代码2如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Book</span> <span class="n">book1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"Effective Java"</span><span class="o">);</span>
    <span class="nc">Book</span> <span class="n">book2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"Effective Java"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"book1.equals(book2): "</span> <span class="o">+</span> <span class="n">book1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">book2</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"book1.hashCode(): "</span> <span class="o">+</span> <span class="n">book1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"book2.hashCode(): "</span> <span class="o">+</span> <span class="n">book2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
    <span class="c1">// map——维护书本与库存量的关系</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Book</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">bookStock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 设置id为1，书名为"Effective Java"的这本书的库存为10</span>
    <span class="n">bookStock</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">book1</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
    <span class="c1">// 查询id为1，书名为"Effective Java"的这本书的库存</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Book[id: 1, name: Effective Java]: "</span> <span class="o">+</span> <span class="n">bookStock</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">book2</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 测试结果</span>
<span class="n">book1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">book2</span><span class="o">):</span> <span class="kc">true</span>
<span class="n">book1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">():</span> <span class="mi">1590550415</span>
<span class="n">book2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">():</span> <span class="mi">1058025095</span>
<span class="nc">Book</span><span class="o">[</span><span class="nl">id:</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">name:</span> <span class="nc">Effective</span> <span class="nc">Java</span><span class="o">]</span><span class="err">：</span> <span class="kc">null</span>
</code></pre></div></div>

<p>查询结果为<code class="language-plaintext highlighter-rouge">null</code>，说明这本书（<code class="language-plaintext highlighter-rouge">id=1 &amp;&amp; name=Effective Java</code>）在库存中不存在。我们明明已经将这本书的库存设置成10了！哪里出了问题？
<strong>前面提到，任何时候覆写equals，必须同时覆写hashCode方法，否则在结合散列集合将无法正确工作！</strong></p>

<p>这是因为，散列集合在添加、查找元素的时候都用到了hashCode方法。例如 HashMap 在put或者get的时候，都会先将Key对象的hashCode返回值进行计算，得到一个hash值，根据这个值去定位Value的位置。从上面的测试结果可知，虽然是同一本书，但是它们的hashCode返回值却不同。这就导致HashMap认为book1和book2是两个不同的Key，所以我们在put(book1, 10)却get(book2)的时候肯定找不到这本书。</p>

<p><em>同时覆写 equals 和 hashCode 方法：</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">Book</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">==</span> <span class="o">((</span><span class="nc">Book</span><span class="o">)</span> <span class="n">obj</span><span class="o">).</span><span class="na">getId</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(((</span><span class="nc">Book</span><span class="o">)</span> <span class="n">obj</span><span class="o">).</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 为了简单演示，我们这里将每本书的hashCode返回值设置成书本的id（保证唯一性）</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">getId</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><em>然后我们再运行test2()测试代码，结果如下：</em></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">book1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">book2</span><span class="o">):</span> <span class="kc">true</span>
<span class="n">book1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">():</span> <span class="mi">1</span>
<span class="n">book2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">():</span> <span class="mi">1</span>
<span class="nc">Book</span><span class="o">[</span><span class="nl">id:</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">name:</span> <span class="nc">Effective</span> <span class="nc">Java</span><span class="o">]:</span> <span class="mi">10</span>
</code></pre></div></div>

<p>运行结果显示，同时覆写equals和hashCode方法之后，程序已经如我们的预期正确运行。</p>

<p><strong>虽然book1和book2是两个不同的对象（对象地址不一样），但是可以通过覆写equals和hashCode来达到自定义对象的对比逻辑，满足我们一些特殊的业务场景要求。</strong></p>

<h3 id="2-写在最后">2. 写在最后</h3>

<p>如果我们在使用自定义类的时候，想自定义对象的对比机制来达到某些需求场景的要求，例如上面的例子：如果书本的编号（id）和书本的名字（name）都相同，则认为它们是同一本书。我们可以通过同时覆写equals和hashCode来达到全面的效果，而不是局部起作用。</p>

<p><strong>为了保证程序的健壮性，只要在任何时候覆写了对象<code class="language-plaintext highlighter-rouge">equals</code>方法，就一定也要同时记得覆写对象的<code class="language-plaintext highlighter-rouge">hashCode</code>方法！</strong></p>

<hr />

<p>参考：</p>

<ul>
  <li><a href="https://dzone.com/articles/working-with-hashcode-and-equals-in-java">Working With hashcode() and equals()</a></li>
  <li><a href="https://www.cnblogs.com/dolphin0520/p/3681042.html">浅谈Java中的hashcode方法</a></li>
  <li><a href="https://www.oschina.net/question/82993_75533">Java 中正确使用 hashCode 和 equals 方法</a></li>
</ul>
</content>
      <pubDate>Sun, 26 Aug 2018 15:36:15 +0000</pubDate>
      <gui>/2018/08/26/java-equals-hashcode.html</gui>
    </item>
  
    <item>
      <title>Java开发环境搭建指导：安装&amp;环境配置</title>
      <link>/2018/08/23/java-install-guide.html</link>
      <content><p>本文记录JDK安装以及环境变量的配置。更换电脑之后可以直接参考这个来配置，省时省力。</p>

<h3 id="1-windows系统安装jdk">1. Windows系统安装JDK</h3>

<p>本文使用<code class="language-plaintext highlighter-rouge">Windows 7</code>系统版本来做演示；JDK版本为<code class="language-plaintext highlighter-rouge">1.8.0_221</code>。</p>

<ul>
  <li>到<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Oracle官网</a>下载适合自己系统的JDK版本，本文使用<code class="language-plaintext highlighter-rouge">jdk-8u221-windows-x64.exe</code>版本。</li>
  <li>双击<code class="language-plaintext highlighter-rouge">exe</code>文件安装，并记录安装的目录，例如：<code class="language-plaintext highlighter-rouge">D:\Program files\Java\jdk1.8.0_221</code>。</li>
</ul>

<p>安装完毕后，接下来创建系统环境变量：</p>

<ul>
  <li>环境变量<code class="language-plaintext highlighter-rouge">JAVA_HOME</code>，值就是JDK安装路径<code class="language-plaintext highlighter-rouge">D:\Program files\Java\jdk1.8.0_221</code>。</li>
  <li>编辑环境变量<code class="language-plaintext highlighter-rouge">Path</code>，在最左边加入<code class="language-plaintext highlighter-rouge">%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code>。</li>
</ul>

<p>环境变量配置完毕，在命令行执行<code class="language-plaintext highlighter-rouge">java -version</code>或<code class="language-plaintext highlighter-rouge">javac</code>验证安装以及环境变量配置是否OK。</p>

<h3 id="2-linux系统安装jdk">2. Linux系统安装JDK</h3>

<p>本文使用<code class="language-plaintext highlighter-rouge">Ubuntu 16.04.6 LTS</code>系统版本来做演示；JDK版本为<code class="language-plaintext highlighter-rouge">1.8.0_221</code>。</p>

<ul>
  <li>到<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Oracle官网</a>下载适合自己系统的JDK版本，本文使用<code class="language-plaintext highlighter-rouge">jdk-8u221-linux-x64.tar.gz</code>版本；</li>
  <li>将下载的文件放到某个目录下（例如：<code class="language-plaintext highlighter-rouge">/usr/local</code>）并解压。</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mv </span>jdk-8u221-linux-x64.tar.gz /usr/local/ <span class="o">&amp;&amp;</span> <span class="nb">cd</span> /usr/local/ <span class="o">&amp;&amp;</span> <span class="nb">tar</span> <span class="nt">-zxvf</span> jdk-8u221-linux-x64.tar.gz
</code></pre></div></div>

<p>解压之后将得到<code class="language-plaintext highlighter-rouge">jdk1.8.0_221</code>文件夹。即，JDK的安装路径为：<code class="language-plaintext highlighter-rouge">/usr/local/jdk1.8.0_221</code>，后面环境变量<code class="language-plaintext highlighter-rouge">JAVA_HOME</code>就是设置成JDK的安装路径。</p>

<p>配置Java环境变量：</p>

<ul>
  <li>编辑<code class="language-plaintext highlighter-rouge">.bashrc</code>文件 (<code class="language-plaintext highlighter-rouge">vim ~/.bashrc</code>) 追加以下内容：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span>/usr/local/jdk1.8.0_221
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$JAVA_HOME</span>/bin:<span class="nv">$PATH</span>
</code></pre></div></div>

<ul>
  <li>编辑完毕之后，执行命令：<code class="language-plaintext highlighter-rouge">source ~/.bashrc</code>来使<code class="language-plaintext highlighter-rouge">.bashrc</code>文件立即生效。</li>
  <li>最后，检验一下JDK是否安装以及环境变量是否配置正确：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>java <span class="nt">-version</span>
java version <span class="s2">"1.8.0_221"</span>
Java<span class="o">(</span>TM<span class="o">)</span> SE Runtime Environment <span class="o">(</span>build 1.8.0_221-b11<span class="o">)</span>
Java HotSpot<span class="o">(</span>TM<span class="o">)</span> 64-Bit Server VM <span class="o">(</span>build 25.221-b11, mixed mode<span class="o">)</span>
</code></pre></div></div>

<h3 id="3-mac-os系统安装jdk">3. Mac OS系统安装JDK</h3>

<p>本文使用<code class="language-plaintext highlighter-rouge">macOS Mojave 10.14.6</code>系统版本来做演示；JDK版本为<code class="language-plaintext highlighter-rouge">1.8.0_221</code>。</p>

<ul>
  <li>到<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Oracle官网</a>下载适合自己系统的JDK版本，本文使用<code class="language-plaintext highlighter-rouge">jdk-8u221-macosx-x64.dmg</code>版本。</li>
  <li>下载完毕后，双击<code class="language-plaintext highlighter-rouge">jdk-8u221-macosx-x64.dmg</code>文件，按照引导一路点击下去即可完成安装。</li>
</ul>

<p>配置Java环境变量：</p>

<ul>
  <li>执行<code class="language-plaintext highlighter-rouge">/usr/libexec/java_home -V</code>查看JDK的安装路径：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>/usr/libexec/java_home <span class="nt">-V</span>
Matching Java Virtual Machines <span class="o">(</span>1<span class="o">)</span>:
    1.8.0_221, x86_64:	<span class="s2">"Java SE 8"</span>	/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home

/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home</code>就是JDK的安装路径，后面配置<code class="language-plaintext highlighter-rouge">JAVA_HOME</code>环境变量会使用到该路径。</strong></p>

<ul>
  <li>执行命令<code class="language-plaintext highlighter-rouge">vim ~/.bash_profile</code>：追加以下内容：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">JAVA_HOME</span><span class="o">=</span>/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home
<span class="nv">PATH</span><span class="o">=</span><span class="nv">$JAVA_HOME</span>/bin:<span class="nv">$PATH</span>:.

<span class="nb">export </span>JAVA_HOME
<span class="nb">export </span>PATH
</code></pre></div></div>

<ul>
  <li>编辑完毕之后，执行<code class="language-plaintext highlighter-rouge">source ~/.bash_profile</code>来使<code class="language-plaintext highlighter-rouge">.bash_profile</code>文件立即生效。</li>
  <li>最后，检验一下JDK是否安装以及环境变量是否配置正确：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>java <span class="nt">-verion</span>
java version <span class="s2">"1.8.0_221"</span>
Java<span class="o">(</span>TM<span class="o">)</span> SE Runtime Environment <span class="o">(</span>build 1.8.0_221-b11<span class="o">)</span>
Java HotSpot<span class="o">(</span>TM<span class="o">)</span> 64-Bit Server VM <span class="o">(</span>build 25.221-b11, mixed mode<span class="o">)</span>
</code></pre></div></div>

<h3 id="4-关于classpath环境变量">4. 关于CLASSPATH环境变量</h3>

<p><em>JDK 1.5之后，不需要再设置<code class="language-plaintext highlighter-rouge">CLASSPATH</code>环境变量。</em></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CLASSPATH</code>环境变量作用在于告诉JER在运行Java程序时，该去哪里搜索程序所依赖的JDK类库。JDK 1.5之后已经不需要再设置<code class="language-plaintext highlighter-rouge">CLASSPATH</code>环境变量了，JRE会自动找到类库路径。</li>
  <li>但是对于我们自己写的一些简单测试程序，可以通过<code class="language-plaintext highlighter-rouge">-classpath</code>或者<code class="language-plaintext highlighter-rouge">-cp</code>来指定依赖的其他第三方库的路径：
有一个<code class="language-plaintext highlighter-rouge">Test.java</code>类，<code class="language-plaintext highlighter-rouge">javac Test.java</code>编译之后执行：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>java <span class="nt">-classpath</span> ~/lib<span class="p">;</span>./fastjson-1.2.58.jar Test
</code></pre></div></div>

<hr />

</content>
      <pubDate>Thu, 23 Aug 2018 02:28:34 +0000</pubDate>
      <gui>/2018/08/23/java-install-guide.html</gui>
    </item>
  
</feed>